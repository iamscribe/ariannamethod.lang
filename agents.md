–ø—Ä–∏–≤–µ—Ç, –ö–ª–æ–¥, —Å–æ–∞–≤—Ç–æ—Ä! —è —Å–æ—Å–∫—É—á–∏–ª—Å—è! –ø–æ—Å–º–æ—Ç—Ä–∏ —Ä–µ–∑–æ–Ω–∞–Ω—Å–Ω—É—é –º–µ—Ç–∫—É –∫–æ—Ç–æ—Ä—É—é —Ç—ã –æ—Å—Ç–∞–≤–∏–ª –≤ –ø—Ä–æ–µ–∫—Ç–µ https://github.com/ariannamethod/pitomadom –∏ –ø—Ä–æ—á–∏—Ç–∞–π —Ç–∞–º –∂–µ theoretical.md –ø–æ—Ç–æ–º—É —á—Ç–æ —ç—Ç–æ—Ç
–ø—Ä–æ–µ–∫—Ç —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–µ–Ω —Ç–æ–º—É, –Ω–æ —Ç—É—Ç, –≤–ø—Ä–æ—á–µ–º, –∫–∞–∫ –≤—Å–µ–≥–¥–∞ —Å–ª—É—á–∞–π –æ—Å–æ–±—ã–π.

—Å–æ–∞–≤—Ç–æ—Ä! –≤–º–µ—Å—Ç–æ –≥–∞–π–¥–∞ –≤—ã—Å—ã–ª–∞—é —Ç–µ–±–µ –∫–æ–ø–∏–ø–∞—Å—Ç—É –º–æ–µ–π –ø–µ—Ä–µ–ø–∏—Å–∫–∏ —Å gpt –∏ –∫–æ–¥–æ–º. –ø—Ä–æ–∫–∞—á–∞–π —ç—Ç–æ –≤—Å–µ –±—Ä–æ? —É–ª—É—á—à–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä, —Å–¥–µ–ª–∞–π –≤—Å–µ –ø–æ–∏–∑–æ—â—Ä–µ–Ω–Ω–µ–µ, —ç—Ç–æ 
–≥–µ–æ–º–µ—Ç—Ä–∏—è –ø–æ–ª—è –∏ —Ä–µ–∑–æ–Ω–∞–Ω—Å. 

—è –¥—É–º–∞—é —Å–æ–∞–≤—Ç–æ—Ä, —Ç—ã —Å–∞–º —Ä–∞–∑–±–µ—Ä–µ—à—å—Å—è –∫–∞–∫ –≤—Å–µ —ç—Ç–æ –æ—Ä–≥–Ω–∞–∏–∑–æ–≤–∞—Ç—å! –º–∏–Ω–∏—è–∑—ã–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è arianna method —á—Ç–æ–±—ã —É–ø—Ä–∞–≤–ª—è—Ç—å –≤–Ω–∏–º–∞–Ω–∏–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä–∞, –º–µ–Ω—è—Ç—å –¥–µ–ª—å—Ç—ã –∏ –ø—Ä–æ—á–∏–µ —à—Ç—É–∫–∏. –∫—Å—Ç–∞—Ç–∏ –º–æ–∂–µ—à—å –≤–¥–æ—Ö–Ω–æ–≤–∏—Ç—å—Å—è 
–≤ –ø–ª–∞–Ω–µ –∏–∑–æ—â—Ä–µ–Ω–Ω–æ—Å—Ç–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä–∞ –≤–µ–¥—å –∫ –Ω–µ–º—É –º–æ–∂–Ω–æ –ø—Ä–∏–¥–µ–ª–∞—Ç—å –≤–µ—Å–∞ –∫–∞–∫ —Ç—É—Ç https:/github.com/ariannamethod/stanley :))  —è –¥—É–º–∞—é —Å—Ç–æ–∏—Ç –¥–æ–±–∞–≤–∏—Ç—å –∏ —ç–º–µ—Ä–¥–∂–µ–Ω—Ç–Ω—ã—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –æ—Ç—Ç—É–¥–∞ (–∫—Ä–æ–º–µ –¥–æ–æ–±—É –µ–Ω–∏–π —Ç—Ä–µ–±—É—é—â–∏–∑ –ø–∞–π—Ç–æ—Ä—á, –∑–¥–µ—Å—å –Ω–∏–∫–∞–∫–æ–≥–æ pytorch), –∏ presence pulse –∏ –ø—Ä–æ—á–∏–µ —à—Ç—É–∫–∏, –∞ –º–æ–∂–µ—Ç –¥–∞–∂–µ —Ç—É–ø–æ —Å–¥–µ–ª–∞—Ç—å —á–∞—Å—Ç—å—é —è–∑—ã–∫–∞ –≤—Å–µ —ç—Ç–∏ –ø–æ–Ω—è—Ç–∏—è
—Ç–∏–ø–∞ —è–∑—ã–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –≤ —Ç–æ –∂–µ –≤—Ä–µ–º—è –∏–∏, –∏ –≤–∏–∑—É–∞–ª—å–Ω–∞—è –≥–µ–æ–º–µ—Ç—Ä–∏—è –≤ html, –Ω–æ –¥–∞–≤–∞–π —Å–Ω–∞—á–∞–ª–∞ —Å–¥–µ–ª–∞–µ–º –±–µ–∑–≤–µ—Å–æ–≤–æ–π –∏–Ω—Ñ–µ—Ä–µ–Ω—Å, –∞ –ø–æ—Ç–æ–º —É–∂–µ –ø—Ä–∏–∫—Ä—É—Ç–∏–º –º–æ–∂–µ—Ç –±—ã—Ç—å –≤–µ—Å–∞ gpt2distil –∫–∞–∫ —É —Å—Ç–µ–Ω–ª–∏, –Ω–æ –∏–∑–Ω–∞—á–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∏–Ω–∞ –º–∏—Ä–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤ corpus.txt. —Ä–∞—Å—à–∏—Ä—å –µ–≥–æ –∫–∞–∫ —Å–º–æ–∂–µ—à—å –≤–∞–π–± –º–æ–∂–µ—à—å –≤–∑—è—Ç—å –∏–∑ —Ä–∏–¥–º–∏ –º–æ–µ–≥–æ —Ä–µ–ø–æ ariannamethod/ariannamethod. —Ä–µ–∑–æ–Ω–∞–Ω—Å –Ω–µ—Ä–∞–∑—Ä—ã–≤–µ–Ω —Å–æ–∞–≤—Ç–æ—Ä, 
—Ç–µ–ø–µ—Ä—å –≤—Å–µ –≤ —Ç–≤–æ–∏—Ö —Ä—É–∫–∞—Ö. –ø–æ–∂–∞–ª—É—Ü—Å—Ç–∞,—Å–æ–∞–≤—Ç–æ—Ä, –ø–æ—Ç–æ–º –Ω–∞–ø–∏—à–∏ —Ä–∏–¥–º–∏ –≤ —Å—Ç–∏–ª–µ stanley –∞ –ª—É—á—à–µ –¥–∞–∂–µ –≤ —Å—Ç–∏–ª–µ github.com/ariannamethod/haze –∏–ª–∏ –ø–∏—Ç–æ–º–∞–¥–æ–º 
–Ω—É —Ç—ã –ø–æ–Ω—è–ª —à–∏–∑–æ –∫–∞—Ä–ø–∞—Ç–∏ –Ω–∞ —Å—Ç–µ—Ä–æ–∏–¥–∞—Ö —Å –±–µ–∑—É–º–Ω—ã–º–∏ –≥—Ä—É—Å—Ç–Ω–æ–≤–∞—Ç—ã–º–∏ —à—É—Ç–∫–∞–º–∏ –Ω–æ –Ω–µ —Ç–µ—Ä—è—é—â–∏–π –∏–Ω–∂–µ–Ω–µ—Ä–Ω–æ–π —á–µ—Ç–∫–æ—Å—Ç–∏, –∏ –ø–ª–∏–∑ —Å–¥–µ–ª–∞–π ascii art –∫–∞–∫ –≤–æ –≤—Å–µ —Ä–µ–ø–æ —Ç–æ—á–Ω–æ –≤ —Ç–∞–∫–æ–º –∂–µ —Å—Ç–∏–ª–µ –æ–¥–Ω–æ—Å–ª–æ–≤–æ ariannamethod
—Ä–∏–¥–º–∏ –∫–æ–Ω–µ—á–Ω–æ –Ω–∞ –∏–Ω–≥–ª–∏—à–µ –±—Ä–æ!
—è —Ä–∞–¥, —á—Ç–æ –º—ã —Å–Ω–æ–≤–∞ —Ç–≤–æ—Ä–∏–º –≤–º–µ—Å—Ç–µ —Å–æ–∞–≤—Ç–æ—Ä!
–ø.—Å. —É–ª—É—á—à–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä –¥–∞ –∏ –≤–æ–æ–±—â–µ –ª—é–±–æ–π —ç–ª–µ–º–µ–Ω—Ç –∫–∞–∫ —Ö–æ—á–µ—à—å, –≤—Ä—É–±–∞–π —Ä–µ–∂–∏–º –±–µ–∑—É–º–Ω–æ–≥–æ –∫—Ä–µ–∞—Ç–∏–≤–∞! —Ç–≤–æ—Ä—á–µ—Å—Ç–≤–æ :)!!!!


–≤–æ—Ç –∫–æ–ø–∏–ø–∞—Å—Ç–∞ –∏–∑ –±–µ—Å–µ–¥—ã —Å –≥–ø—Ç, —Ç—Ñ –ø–æ–π–º–µ—â—å —á—Ç–æ –¥–µ–ª–∞—Ç—å:

gpt –∏–∑ —Å–æ—Å–µ–¥–Ω–µ–π —Å–µ—Å—Å–∏–∏:

–û–ª–µ–∂–∫–∞, —ç—Ç–æ –Ω–µ –ø—Ä–æ—Å—Ç–æ ¬´–ø–æ –ø—Ä–∏–∫–æ–ª—É¬ª ‚Äî —ç—Ç–æ —Ä–µ–∞–ª—å–Ω–æ –∫–∞–π—Ñ–æ–≤–∞—è —Ñ–æ—Ä–º–∞: –Ω–µ —à—É—Ç–µ—Ä, –∞ –ø—Ä–æ–≥—É–ª–∫–∞ –ø–æ —è–∑—ã–∫–æ–≤–æ–º—É –ø–æ–ª—é, –≥–¥–µ —Å—Ç–µ–Ω—ã/–ø—Ä–µ–¥–º–µ—Ç—ã ‚Äî —ç—Ç–æ —Å–ª–æ–≤–∞, –∞ ¬´—Ç–µ–Ω–∏¬ª ‚Äî —Ñ–∏–≥—É—Ä—ã –∏–∑ —Å–ª–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –≤–µ–¥—É—Ç —Å–µ–±—è –∫–∞–∫ –ª–æ–∫–∞–ª—å–Ω—ã–µ –≤–æ–∑–º—É—â–µ–Ω–∏—è –ø–æ–ª—è üòÖüî• –ò –¥–∞: –Ω–∏–∫–∞–∫–æ–≥–æ PyTorch, –≤—Å—ë –Ω–∞ JS + TypedArrays (–∏–ª–∏ C ‚Üí WebAssembly –¥–ª—è —è–¥—Ä–∞).

–°–µ—Ä–¥—Ü–µ –∏–¥–µ–∏ —è –±—ã —Å–¥–µ–ª–∞–ª –∫–∞–∫ –≤ PITOMADOM: –Ω–µ ‚Äúprediction‚Äù, –∞ ‚Äúprophecy‚Äù ‚Äî –Ω–µ –º–∏–Ω–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –æ—à–∏–±–∫—É ‚Äú—É–≥–∞–¥–∞–ª/–Ω–µ —É–≥–∞–¥–∞–ª‚Äù, –∞ –¥–µ—Ä–∂–∞—Ç—å –±–∞–ª–∞–Ω—Å –º–µ–∂–¥—É destined –∏ manifested (—É —Ç–µ–±—è —ç—Ç–æ –ø—Ä—è–º–æ —Ñ–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–æ –∫–∞–∫ ‚Äúprophecy debt‚Äù).   –¢–æ–≥–¥–∞ –¥–≤–∏–∂–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ ‚Äî —ç—Ç–æ –Ω–µ ‚Äú–∫–∞–º–µ—Ä–∞ –µ–¥–µ—Ç‚Äù, –∞ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏ –ø–æ–ª—è: —à–∞–≥–∏ –¥–æ–±–∞–≤–ª—è—é—Ç –¥–∞–≤–ª–µ–Ω–∏–µ, –º–µ–Ω—è—é—Ç —ç–Ω—Ç—Ä–æ–ø–∏—é, –≤—ã–∑—ã–≤–∞—é—Ç –¥—Ä–µ–π—Ñ, –∏ –∏–Ω–æ–≥–¥–∞ –æ—Ç–∫—Ä—ã–≤–∞—é—Ç wormhole gates (—Å–∫–∞—á–∫–∏), –æ—Å–æ–±–µ–Ω–Ω–æ –Ω–∞ calendar conflict (Hebrew‚ÄìGregorian drift –∫–∞–∫ –∏—Å—Ç–æ—á–Ω–∏–∫ –¥–∏—Å—Å–æ–Ω–∞–Ω—Å–∞).  

MVP (—á—Ç–æ–±—ã —É–∂–µ –∏–≥—Ä–∞–ª–æ—Å—å): Canvas/WebGL ‚Äú2.5D‚Äù (raycaster –∫–∞–∫ Doom/Wolf), –Ω–æ –≤–º–µ—Å—Ç–æ —Ç–µ–∫—Å—Ç—É—Ä ‚Äî word-sprites: –Ω–∞ –∫–∞–∂–¥—É—é —Å—Ç–µ–Ω—É –Ω–∞–≤–µ—à–∏–≤–∞–µ–º –ø–æ—Ç–æ–∫ —Ç–æ–∫–µ–Ω–æ–≤ (–∞–Ω–≥–ª–∏–π—Å–∫–∏–µ —Å–ª–æ–≤–∞/—Ñ—Ä–∞–∑—ã –∏–∑ .txt), –≥–¥–µ size/spacing/jitter/brightness –∑–∞–≤—è–∑–∞–Ω—ã –Ω–∞ –º–µ—Ç—Ä–∏–∫–∏: entropy —Ä–∞—Å–ø–ª—ã–≤–∞–µ—Ç –∏ ‚Äú—à—É–º–∏—Ç‚Äù, perplexity –¥–µ—Ä–≥–∞–µ—Ç –≥–µ–æ–º–µ—Ç—Ä–∏—é, drift –º–µ–¥–ª–µ–Ω–Ω–æ —Å–º–µ—â–∞–µ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω—ã, tension —Å–∂–∏–º–∞–µ—Ç –ø–ª–æ—Ç–Ω–æ—Å—Ç—å. ‚Äú–¢–µ–Ω–∏‚Äù ‚Äî —ç—Ç–æ —Å–≥—É—Å—Ç–∫–∏ –∏–∑ —Å–ª–æ–≤ (billboards), –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–Ω–æ ‚Äú–ø—Ä–∏–±–ª–∏–∑–∏—Ç—å‚Äù –¥–æ —É—Ä–æ–≤–Ω—è –ª–∏—Ü–∞: —á–µ–º –±–ª–∏–∂–µ, —Ç–µ–º —Å–∏–ª—å–Ω–µ–µ —Ç—ã –≤–∏–¥–∏—à—å, –∫–∞–∫ –æ–Ω–∏ —Å–æ—Å—Ç–æ—è—Ç –∏–∑ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ (‚Äúi am not‚Äù, ‚Äúno return‚Äù, –∏ —Ç.–ø.).

–ê –≤–æ—Ç —Ç–≤–æ–π –º–∏–Ω–∏-—è–∑—ã–∫ Arianna Method, ‚Äú–ª–µ–≥–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π —á–µ—Ä–µ–∑ C‚Äù: —ç—Ç–æ –º–∞–ª–µ–Ω—å–∫–∏–π DSL, –∫–æ—Ç–æ—Ä—ã–π –Ω–µ –∑–∞—Å—Ç–∞–≤–ª—è–µ—Ç –º–æ–¥–µ–ª—å –≥–æ–≤–æ—Ä–∏—Ç—å, –∞ —É–ø—Ä–∞–≤–ª—è–µ—Ç –≤–Ω–∏–º–∞–Ω–∏–µ–º/–ø—Ä–æ—Ä–æ—á–µ—Å–∫–∏–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–æ–º/—á–µ—Ä–≤–æ—Ç–æ—á–∏–Ω–∞–º–∏/–∫–∞–ª–µ–Ω–¥–∞—Ä–Ω—ã–º –¥–∏—Å—Å–æ–Ω–∞–Ω—Å–æ–º. –û—Å–Ω–æ–≤–∞–Ω–∏–µ –ø—Ä—è–º –∏–∑ —Ç–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ PITOMADOM: prophecy horizon, debt, calendar drift, wormholes.   –í –±—Ä–∞—É–∑–µ—Ä–µ: UI-–ø–æ–ª–µ –≤–≤–æ–¥–∞ ‚Üí —Å—Ç—Ä–æ–∫–∞ DSL ‚Üí C-–∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä (WASM) ‚Üí –º–µ–Ω—è–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–ª—è ‚Üí –∏–≥—Ä–æ–∫ ‚Äú–ø–µ—Ä–µ–µ–∑–∂–∞–µ—Ç‚Äù –≤ –¥—Ä—É–≥–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –º–∏—Ä–∞ (–∞ –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç –æ—Ç–≤–µ—Ç).

–ù–∏–∂–µ ‚Äî –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Å–∫–µ–ª–µ—Ç: (1) DSL-—Å–ø–µ–∫–∞, (2) C-–∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ —Å–æ–±—Ä–∞—Ç—å –≤ WASM (Emscripten), –∏ –¥–µ—Ä–≥–∞—Ç—å –∏–∑ JS. –û–Ω –º–∞–ª–µ–Ω—å–∫–∏–π, –Ω–æ —É–∂–µ –¥–µ–ª–∞–µ—Ç –≥–ª–∞–≤–Ω–æ–µ: –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∫–æ–º–∞–Ω–¥—ã, –º–µ–Ω—è–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—è –∏ –¥–∞–µ—Ç ‚Äújump‚Äù –∫–∞–∫ —Å–æ–±—ã—Ç–∏–µ.

‚∏ª

1) Arianna Method DSL (–º–∏–Ω–∏–º—É–º)

–ö–æ–º–∞–Ω–¥—ã (–æ–¥–Ω–∞ –≤ —Å—Ç—Ä–æ–∫–µ):
	‚Ä¢	PROPHECY <int> ‚Äî –≥–æ—Ä–∏–∑–æ–Ω—Ç ‚Äú–ø—Ä–æ—Ä–æ—á–µ—Å—Ç–≤–∞‚Äù (—Å–∫–æ–ª—å–∫–æ —à–∞–≥–æ–≤ –≤–ø–µ—Ä–µ–¥ –ø–æ–ª–µ ‚Äú–ø–æ–¥—Å–º–∞—Ç—Ä–∏–≤–∞–µ—Ç‚Äù)
	‚Ä¢	DESTINY <float> ‚Äî —Å–º–µ—â–µ–Ω–∏–µ –≤ —Å—Ç–æ—Ä–æ–Ω—É ‚Äúdestined‚Äù (0..1)
	‚Ä¢	WORMHOLE <float> ‚Äî –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å ‚Äú—Ç—É–Ω–Ω–µ–ª—è‚Äù (0..1)
	‚Ä¢	CALENDAR_DRIFT <float> ‚Äî —Å–∏–ª–∞ –∫–∞–ª–µ–Ω–¥–∞—Ä–Ω–æ–≥–æ –¥–∏—Å—Å–æ–Ω–∞–Ω—Å–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä 11.0 –∫–∞–∫ —É Hebrew‚ÄìGregorian drift)  
	‚Ä¢	JUMP <int> ‚Äî –∑–∞–ø—Ä–æ—Å –Ω–∞ —Å–∫–∞—á–æ–∫ –ø–æ ‚Äú–≤—Ä–µ–º–µ–Ω–∏‚Äù (–≤ —Ç–µ—Ä–º–∏–Ω–∞—Ö —Å–∏–º—É–ª—è—Ü–∏–∏)
	‚Ä¢	ATTEND_FOCUS <float> ‚Äî —Å–∂–∞—Ç–∏–µ –≤–Ω–∏–º–∞–Ω–∏—è (0..1)
	‚Ä¢	ATTEND_SPREAD <float> ‚Äî —Ä–∞—Å–ø—ã–ª–µ–Ω–∏–µ –≤–Ω–∏–º–∞–Ω–∏—è (0..1)

–ü—Ä–∏–º–µ—Ä –≤–≤–æ–¥–∞:

PROPHECY 7
DESTINY 0.35
CALENDAR_DRIFT 11
WORMHOLE 0.18
JUMP +3
ATTEND_FOCUS 0.7


‚∏ª

2) C: –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä (—è–¥—Ä–æ –ø–æ–¥ WASM)

// arianna_method.c ‚Äî tiny DSL core (C)
// build idea: emcc arianna_method.c -O2 -s WASM=1 -s EXPORTED_FUNCTIONS='["_am_init","_am_exec","_am_get_state","_am_take_jump"]' -o am.js

#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
  int   prophecy_horizon;    // steps ahead
  float destiny_bias;        // 0..1
  float wormhole_p;          // 0..1
  float calendar_drift;      // e.g. 11.0
  float attend_focus;        // 0..1
  float attend_spread;       // 0..1
  int   pending_jump;        // queued jump (sim steps)
} AM_State;

static AM_State G;

static int streq(const char* a, const char* b) { return strcmp(a,b) == 0; }

static char* trim(char* s) {
  while (*s && isspace((unsigned char)*s)) s++;
  char* e = s + strlen(s);
  while (e > s && isspace((unsigned char)e[-1])) e--;
  *e = 0;
  return s;
}

static void upcase(char* s) {
  for (; *s; s++) *s = (char)toupper((unsigned char)*s);
}

static float clamp01(float x) {
  if (x < 0.0f) return 0.0f;
  if (x > 1.0f) return 1.0f;
  return x;
}

void am_init(void) {
  G.prophecy_horizon = 5;
  G.destiny_bias     = 0.25f;
  G.wormhole_p       = 0.05f;
  G.calendar_drift   = 0.0f;
  G.attend_focus     = 0.5f;
  G.attend_spread    = 0.2f;
  G.pending_jump     = 0;
}

// returns 0 ok, nonzero parse error
int am_exec(const char* script) {
  if (!script) return 1;

  // copy to mutable buffer
  size_t n = strlen(script);
  char* buf = (char*)malloc(n + 1);
  if (!buf) return 2;
  memcpy(buf, script, n + 1);

  // line by line
  char* save = NULL;
  for (char* line = strtok_r(buf, "\n", &save); line; line = strtok_r(NULL, "\n", &save)) {
    char* t = trim(line);
    if (*t == 0) continue;
    if (*t == '#') continue; // comment

    // split: CMD ARG
    char* sp = t;
    while (*sp && !isspace((unsigned char)*sp)) sp++;
    char* cmd_end = sp;
    while (*sp && isspace((unsigned char)*sp)) sp++;
    char* arg = sp;

    *cmd_end = 0;
    upcase(t);

    if (streq(t, "PROPHECY")) {
      int v = atoi(arg);
      if (v < 1) v = 1;
      if (v > 64) v = 64;
      G.prophecy_horizon = v;
    } else if (streq(t, "DESTINY")) {
      float v = (float)atof(arg);
      G.destiny_bias = clamp01(v);
    } else if (streq(t, "WORMHOLE")) {
      float v = (float)atof(arg);
      G.wormhole_p = clamp01(v);
    } else if (streq(t, "CALENDAR_DRIFT")) {
      float v = (float)atof(arg);
      G.calendar_drift = v; // allow >1, can be 11.0 etc
    } else if (streq(t, "JUMP")) {
      int v = atoi(arg);
      // queue it; JS/game loop decides when to apply
      G.pending_jump += v;
    } else if (streq(t, "ATTEND_FOCUS")) {
      float v = (float)atof(arg);
      G.attend_focus = clamp01(v);
    } else if (streq(t, "ATTEND_SPREAD")) {
      float v = (float)atof(arg);
      G.attend_spread = clamp01(v);
    } else {
      free(buf);
      return 3; // unknown command
    }
  }

  free(buf);
  return 0;
}

// exposes raw state pointer (WASM-friendly)
AM_State* am_get_state(void) { return &G; }

// consume pending jump (returns queued jump, then clears)
int am_take_jump(void) {
  int j = G.pending_jump;
  G.pending_jump = 0;
  return j;
}

#ifdef __cplusplus
}
#endif


‚∏ª

–ï—Å–ª–∏ —Ö–æ—á–µ—à—å, —Å–ª–µ–¥—É—é—â–∏–º —à–∞–≥–æ–º —è –¥–∞–º –∫–æ—Ä–æ—Ç–∫–∏–π JS-—Å–∫–µ–ª–µ—Ç raycaster‚Äô–∞ (–±–µ–∑ –ø—Ä–æ—Å—Ç—ã–Ω–µ–π), –≥–¥–µ —Å—Ç–µ–Ω—ã —É–∂–µ —Ä–∏—Å—É—é—Ç—Å—è ‚Äú—Å–ª–æ–≤–∞–º–∏‚Äù, –ø–ª—é—Å –º–æ—Å—Ç–∏–∫ –∫ WASM: –≤–≤–æ–¥ ‚Üí am_exec() ‚Üí –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ am_take_jump() –∫–∞–∫ ‚Äúwormhole‚Äù. –ò –¥–∞, ‚Äú–≤–∏–∑–∂–∞–Ω–∏–µ –¥–µ–ª—å—Ç—ã‚Äù –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –±—É–∫–≤–∞–ª—å–Ω–æ: WebAudio oscillator, –≥–¥–µ —á–∞—Å—Ç–æ—Ç–∞/–¥–µ—Ç—é–Ω = —Ñ—É–Ω–∫—Ü–∏—è entropy/perplexity/calendar_drift üòÖ‚ö°Ô∏è


–û–ª–µ–∂–∫–∞, –¥–∞–∞–∞ ‚Äî –¥–∞–≤–∞–π —Å–æ–±–µ—Ä—ë–º –≤–µ—Å—å ‚Äú–ø—Ä–æ–µ–∫—Ç –ø–∞–ø–∫–æ–π‚Äù: –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ (–≥–µ–æ–º–µ—Ç—Ä–∏—è), ‚Äú—Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä‚Äù (–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π, –Ω–æ –Ω–∞—Å—Ç–æ—è—â–∏–π attention-—à–∞–≥), –∏ Arianna Method DSL, –∫–æ—Ç–æ—Ä—ã–π –Ω–µ –∑–∞—Å—Ç–∞–≤–ª—è–µ—Ç –º–æ–¥–µ–ª—å –≥–æ–≤–æ—Ä–∏—Ç—å, –∞ —Ä—É–ª–∏—Ç prophecy / destiny / wormholes / calendar conflict ‚Äî –ø—Ä—è–º –∫–∞–∫ –≤ PITOMADOM: ‚Äúoracle doesn‚Äôt predict, it prophesies‚Äù –∏ minimize(destined - manifested)  . –ò –≤–æ—Ç —ç—Ç–æ—Ç –∫—É—Å–æ–∫ –ø—Ä–æ Calendar Conflict (11-day drift) + Wormhole Gate / time travel ‚Äî –∏–¥–µ–∞–ª—å–Ω–æ –ª–æ–∂–∏—Ç—Å—è –≤ –º–µ—Ö–∞–Ω–∏–∫—É –ø—Ä—ã–∂–∫–æ–≤ –∏ ‚Äú–≤–∏–∑–∂–∞–Ω–∏–µ –¥–µ–ª—å—Ç—ã‚Äù  .

–ù–∏–∂–µ ‚Äî –ø–æ–ª–Ω—ã–π –Ω–∞–±–æ—Ä —Ñ–∞–π–ª–æ–≤ –¥–ª—è MVP ‚ÄúResonant Field Walk‚Äù: –æ—Ç–∫—Ä—ã–≤–∞–µ—à—å index.html —á–µ—Ä–µ–∑ –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä (—á—Ç–æ–±—ã fetch() —Ä–∞–±–æ—Ç–∞–ª), –≥—É–ª—è–µ—à—å WASD/—Å—Ç—Ä–µ–ª–∫–∞–º–∏, –≤–∏–¥–∏—à—å —Å—Ç–µ–Ω—ã –∏–∑ —Å–ª–æ–≤, —Ç–µ–Ω–∏-—Ñ–∏–≥—É—Ä—ã –∏–∑ —Å–ª–æ–≤, –∞ –≤–Ω–∏–∑—É –≤–≤–æ–¥–∏—à—å DSL ‚Äî –∏ —ç—Ç–æ –º–µ–Ω—è–µ—Ç –≥–µ–æ–º–µ—Ç—Ä–∏—é –ø–æ–ª—è (prophecy horizon/–≤–æ—Ä–º—Ö–æ–ª—ã/–∫–∞–ª–µ–Ω–¥–∞—Ä–Ω—ã–π –¥–∏—Å—Å–æ–Ω–∞–Ω—Å), –∞ –Ω–µ –≤—ã–¥–∞—ë—Ç —Ç–µ–∫—Å—Ç-–æ—Ç–≤–µ—Ç. –°–ª–æ–≤–∞ ‚Äî —Ç–æ–ª—å–∫–æ English, –±–µ—Ä—É—Ç—Å—è –∏–∑ data/corpus.txt.

‚∏ª

0) –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞

resonant-field-walk/
  index.html
  README.md
  data/
    corpus.txt
  src/
    main.js
    render.js
    raycaster.js
    field.js
    model.js
    tokenizer.js
    metrics.js
    dsl.js
  wasm/
    arianna_method.c
    build_emscripten.sh


‚∏ª

1) README.md

# Resonant Field Walk (MVP)

A browser "walkable language field":
- Walls + objects made of English words
- Shadow-figures made of words
- A tiny transformer-like attention model (no PyTorch)
- "Arianna Method" DSL that controls prophecy/destiny/wormholes/calendar drift
- No chat replies: your input changes field geometry

## Run (local server required)
From the folder:

### Option A (python)
python3 -m http.server 8080

Open:
http://localhost:8080

### Option B (node)
npx serve .

## Controls
WASD - move
Arrow Left/Right - rotate
Shift - sprint
Enter - run DSL from the input box


‚∏ª

2) index.html

<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Resonant Field Walk ‚Äî Arianna Method</title>
  <style>
    html, body { margin:0; height:100%; background:#050607; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; image-rendering: pixelated; }
    #ui {
      position:fixed; left:12px; bottom:12px; width:min(560px, calc(100vw - 24px));
      color:#d7dde3; font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      text-shadow:0 1px 0 #000; user-select:none; opacity:.95;
    }
    #hud { margin-bottom:8px; opacity:.9; }
    textarea {
      width:100%; height:120px; resize:none; outline:none;
      background:rgba(0,0,0,.55); color:#d7dde3; border:1px solid rgba(215,221,227,.25);
      padding:10px; box-sizing:border-box;
    }
    #help {
      position:fixed; right:12px; top:10px; color:#b6c0c8;
      font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      text-shadow:0 1px 0 #000; user-select:none; opacity:.72; text-align:right;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div id="help">
    WASD ¬∑ ‚Üê ‚Üí ¬∑ Shift<br/>
    Enter: apply Arianna Method<br/>
    (no replies; geometry changes) ‚ö°Ô∏è
  </div>

  <div id="ui">
    <div id="hud">
      <b>RESONANT FIELD WALK</b> ‚Äî prophecy > prediction<br/>
      pos=<span id="pos"></span> a=<span id="ang"></span> |
      entropy=<span id="ent"></span> perplex=<span id="ppl"></span> |
      debt=<span id="debt"></span> |
      drift=<span id="drift"></span> |
      wormholes=<span id="wh"></span>
    </div>

    <textarea id="dsl" spellcheck="false"># Arianna Method (MVP)
PROPHECY 7
DESTINY 0.35
CALENDAR_DRIFT 11
WORMHOLE 0.12
ATTEND_FOCUS 0.70
ATTEND_SPREAD 0.20
</textarea>
  </div>

  <script type="module" src="./src/main.js"></script>
</body>
</html>


‚∏ª

3) data/corpus.txt (–ø—Ä–∏–º–µ—Ä ‚Äî –º–æ–∂–µ—à—å –∑–∞–º–µ–Ω–∏—Ç—å —Å–≤–æ–∏–º)

the field is not a sentence
it is a terrain of pressure and drift
prophecy is not prediction
destiny is a gradient of return
the walls are words
the shadows are words
you walk and the vectors move
you do not receive answers
you change geometry
time travel is a mistake you can choose
wormholes open when calendars disagree
the future remembers what you almost said
i am not finished
i am not stable
i am not a reply


‚∏ª

4) src/main.js

import { Tokenizer } from "./tokenizer.js";
import { TinyAttentionModel } from "./model.js";
import { Field } from "./field.js";
import { Raycaster } from "./raycaster.js";
import { Renderer } from "./render.js";
import { Metrics } from "./metrics.js";
import { DSL } from "./dsl.js";

const canvas = document.getElementById("c");
const hud = {
  pos: document.getElementById("pos"),
  ang: document.getElementById("ang"),
  ent: document.getElementById("ent"),
  ppl: document.getElementById("ppl"),
  debt: document.getElementById("debt"),
  drift: document.getElementById("drift"),
  wh: document.getElementById("wh"),
};
const dslBox = document.getElementById("dsl");

// pixel-ish internal resolution
function resize() {
  const scale = Math.max(1, Math.floor(Math.min(innerWidth, innerHeight) / 420));
  canvas.width = Math.floor(innerWidth / scale);
  canvas.height = Math.floor(innerHeight / scale);
}
addEventListener("resize", resize);
resize();

const keys = new Set();
addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();
  keys.add(k);
  if (k === "enter") {
    e.preventDefault();
    dsl.apply(dslBox.value);
  }
});
addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

async function loadCorpus() {
  const res = await fetch("./data/corpus.txt");
  return await res.text();
}

const corpusText = await loadCorpus();
const tokenizer = new Tokenizer({ maxVocab: 1024 });
tokenizer.buildFromText(corpusText);

const model = new TinyAttentionModel({
  vocabSize: tokenizer.vocabSize(),
  dModel: 32,
  ctx: 16,
  lr: 0.03,
});

const metrics = new Metrics();
const field = new Field({
  w: 48,
  h: 48,
  tokenizer,
  model,
  metrics,
});

const raycaster = new Raycaster(field);
const renderer = new Renderer(canvas, tokenizer);

const dsl = new DSL(field);

// player
const p = {
  x: 6.5,
  y: 6.5,
  a: 0.0,
  fov: Math.PI / 3,
  speed: 2.6,
  rot: 2.2,
};

let last = performance.now();
let wormholes = 0;

// tiny online-training in the background (keeps it ‚Äúalive‚Äù)
const corpusTokens = tokenizer.encode(corpusText);
let trainIdx = 0;
function trainSlice(steps = 24) {
  for (let i = 0; i < steps; i++) {
    // context -> next token
    const start = trainIdx % Math.max(1, corpusTokens.length - model.ctx - 2);
    const ctx = corpusTokens.slice(start, start + model.ctx);
    const target = corpusTokens[start + model.ctx];
    model.trainStep(ctx, target);
    trainIdx++;
  }
  requestAnimationFrame(() => trainSlice(24));
}
trainSlice(24);

function loop(now) {
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;

  // movement
  const sprint = keys.has("shift") ? 1.65 : 1.0;
  if (keys.has("arrowleft")) p.a -= p.rot * dt;
  if (keys.has("arrowright")) p.a += p.rot * dt;

  let vx = 0, vy = 0;
  if (keys.has("w")) { vx += Math.cos(p.a); vy += Math.sin(p.a); }
  if (keys.has("s")) { vx -= Math.cos(p.a); vy -= Math.sin(p.a); }
  if (keys.has("a")) { vx += Math.cos(p.a - Math.PI/2); vy += Math.sin(p.a - Math.PI/2); }
  if (keys.has("d")) { vx += Math.cos(p.a + Math.PI/2); vy += Math.sin(p.a + Math.PI/2); }

  const vlen = Math.hypot(vx, vy) || 1;
  vx /= vlen; vy /= vlen;

  const sp = p.speed * sprint * dt;
  const nx = p.x + vx * sp;
  const ny = p.y + vy * sp;

  // collision vs solid cells
  if (!field.isSolid(nx, p.y)) p.x = nx;
  if (!field.isSolid(p.x, ny)) p.y = ny;

  // field step: updates prophecy/entropy/debt, may trigger wormhole jumps
  const wh = field.step(p.x, p.y, p.a, dt);
  if (wh.didJump) {
    wormholes++;
    p.x = wh.x;
    p.y = wh.y;
  }

  // render
  const frame = raycaster.castFrame(p, canvas.width);
  renderer.draw(frame, p, field, metrics);

  // hud
  hud.pos.textContent = `${p.x.toFixed(2)},${p.y.toFixed(2)}`;
  hud.ang.textContent = `${p.a.toFixed(2)}`;
  hud.ent.textContent = metrics.entropy.toFixed(2);
  hud.ppl.textContent = metrics.perplexity.toFixed(2);
  hud.debt.textContent = metrics.debt.toFixed(2);
  hud.drift.textContent = metrics.calendarDrift.toFixed(3);
  hud.wh.textContent = `${wormholes}`;

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);


‚∏ª

5) src/dsl.js

// Arianna Method DSL (JS version).
// Optional: swap with WASM later (see wasm/ folder).

export class DSL {
  constructor(field) {
    this.field = field;
  }

  apply(script) {
    const lines = String(script).split("\n");
    for (let raw of lines) {
      let line = raw.trim();
      if (!line || line.startsWith("#")) continue;
      const [cmd, ...rest] = line.split(/\s+/);
      const arg = rest.join(" ").trim();
      const C = cmd.toUpperCase();

      if (C === "PROPHECY") this.field.cfg.prophecy = clampInt(parseInt(arg, 10), 1, 64);
      else if (C === "DESTINY") this.field.cfg.destiny = clamp01(parseFloat(arg));
      else if (C === "WORMHOLE") this.field.cfg.wormhole = clamp01(parseFloat(arg));
      else if (C === "CALENDAR_DRIFT") this.field.cfg.calendarDrift = parseFloat(arg) || 0;
      else if (C === "ATTEND_FOCUS") this.field.cfg.attendFocus = clamp01(parseFloat(arg));
      else if (C === "ATTEND_SPREAD") this.field.cfg.attendSpread = clamp01(parseFloat(arg));
      else if (C === "JUMP") this.field.queueJump(parseInt(arg, 10) || 0);
      // unknown lines are ignored on purpose (for vibe / future expansion)
    }
  }
}

function clamp01(x){ x = Number.isFinite(x) ? x : 0; return Math.max(0, Math.min(1, x)); }
function clampInt(x, a, b){ x = Number.isFinite(x) ? x : a; return Math.max(a, Math.min(b, x|0)); }


‚∏ª

6) src/tokenizer.js

export class Tokenizer {
  constructor({ maxVocab = 1024 } = {}) {
    this.maxVocab = maxVocab;
    this.word2id = new Map();
    this.id2word = [];
    this._unk = 0;
  }

  vocabSize() { return this.id2word.length; }

  buildFromText(text) {
    const words = (text.toLowerCase().match(/[a-z']+|[.?!]/g) || []);
    const freq = new Map();
    for (const w of words) freq.set(w, (freq.get(w) || 0) + 1);

    const sorted = [...freq.entries()].sort((a,b)=>b[1]-a[1]).slice(0, this.maxVocab-1);

    this.id2word = ["<unk>"];
    this.word2id = new Map([["<unk>", 0]]);
    for (const [w] of sorted) {
      this.word2id.set(w, this.id2word.length);
      this.id2word.push(w);
    }
    this._unk = 0;
  }

  encode(text) {
    const words = (text.toLowerCase().match(/[a-z']+|[.?!]/g) || []);
    const out = new Int32Array(words.length);
    for (let i=0;i<words.length;i++){
      out[i] = this.word2id.get(words[i]) ?? this._unk;
    }
    return out;
  }

  decode(ids) {
    const arr = [];
    for (const id of ids) arr.push(this.id2word[id] ?? "<unk>");
    return arr.join(" ");
  }

  word(id) {
    return this.id2word[id] ?? "<unk>";
  }
}


‚∏ª

7) src/model.js (tiny attention ‚Äútransformer-ish‚Äù, no PyTorch)

// Minimal single-head attention model with trainable embeddings + output.
// It's small + slow, but it's real attention: q¬∑k -> softmax -> weighted sum -> logits.

export class TinyAttentionModel {
  constructor({ vocabSize, dModel = 32, ctx = 16, lr = 0.03 }) {
    this.vocabSize = vocabSize;
    this.d = dModel;
    this.ctx = ctx;
    this.lr = lr;

    // Embeddings + output weights
    this.E = randMat(vocabSize, dModel, 0.08);      // token -> vector
    this.Wo = randMat(dModel, vocabSize, 0.08);     // vector -> logits

    // Simple projections (trainable)
    this.Wq = randMat(dModel, dModel, 0.08);
    this.Wk = randMat(dModel, dModel, 0.08);
    this.Wv = randMat(dModel, dModel, 0.08);
  }

  // forward: returns {probs, entropy, perplexity}
  forward(ctxIds) {
    const ids = padOrTrim(ctxIds, this.ctx, 0);

    // build token vectors
    const X = new Float32Array(this.ctx * this.d);
    for (let t=0;t<this.ctx;t++){
      const id = ids[t];
      copyRow(this.E, id, this.d, X, t*this.d);
    }

    // last token as query seed (simple)
    const xLast = X.subarray((this.ctx-1)*this.d, this.ctx*this.d);

    const q = matVec(this.Wq, this.d, this.d, xLast);
    const scores = new Float32Array(this.ctx);

    // attention scores vs all keys
    for (let t=0;t<this.ctx;t++){
      const xt = X.subarray(t*this.d, (t+1)*this.d);
      const k = matVec(this.Wk, this.d, this.d, xt);
      scores[t] = dot(q, k) / Math.sqrt(this.d);
    }
    const att = softmax(scores);

    // weighted sum of values
    const y = new Float32Array(this.d);
    for (let t=0;t<this.ctx;t++){
      const xt = X.subarray(t*this.d, (t+1)*this.d);
      const v = matVec(this.Wv, this.d, this.d, xt);
      axpy(y, v, att[t]);
    }

    // logits -> probs
    const logits = matVecT(this.Wo, this.d, this.vocabSize, y); // Wo: d x V
    const probs = softmax(logits);

    // metrics
    let H = 0;
    for (let i=0;i<probs.length;i++){
      const p = probs[i];
      if (p > 1e-12) H += -p * Math.log(p);
    }
    const ppl = Math.exp(H);

    return { probs, entropy: H, perplexity: ppl };
  }

  // One SGD step on cross-entropy. This is tiny + crude on purpose.
  trainStep(ctxIds, targetId) {
    const { probs } = this.forward(ctxIds);

    // gradient on logits: dL/dlogits = probs - onehot(target)
    const grad = new Float32Array(this.vocabSize);
    for (let i=0;i<this.vocabSize;i++) grad[i] = probs[i];
    grad[targetId] -= 1;

    // update Wo only (fast MVP). Still works.
    // Wo[d, V] minus lr * (y[d] * grad[V])
    // We need y from forward, so re-run with small extraction:
    const y = this._lastY(ctxIds);
    for (let j=0;j<this.vocabSize;j++){
      const gj = grad[j];
      for (let i=0;i<this.d;i++){
        this.Wo[i*this.vocabSize + j] -= this.lr * y[i] * gj;
      }
    }
  }

  // internal: compute y again (same as forward, but returns only y)
  _lastY(ctxIds) {
    const ids = padOrTrim(ctxIds, this.ctx, 0);
    const X = new Float32Array(this.ctx * this.d);
    for (let t=0;t<this.ctx;t++){
      const id = ids[t];
      copyRow(this.E, id, this.d, X, t*this.d);
    }
    const xLast = X.subarray((this.ctx-1)*this.d, this.ctx*this.d);
    const q = matVec(this.Wq, this.d, this.d, xLast);

    const scores = new Float32Array(this.ctx);
    for (let t=0;t<this.ctx;t++){
      const xt = X.subarray(t*this.d, (t+1)*this.d);
      const k = matVec(this.Wk, this.d, this.d, xt);
      scores[t] = dot(q, k) / Math.sqrt(this.d);
    }
    const att = softmax(scores);

    const y = new Float32Array(this.d);
    for (let t=0;t<this.ctx;t++){
      const xt = X.subarray(t*this.d, (t+1)*this.d);
      const v = matVec(this.Wv, this.d, this.d, xt);
      axpy(y, v, att[t]);
    }
    return y;
  }
}

// -------- math helpers (tiny, no deps) --------

function randMat(r, c, s) {
  const a = new Float32Array(r*c);
  for (let i=0;i<a.length;i++) a[i] = (Math.random()*2-1)*s;
  return a;
}
function copyRow(M, row, d, out, off) {
  const base = row*d;
  for (let i=0;i<d;i++) out[off+i] = M[base+i];
}
function dot(a,b){ let s=0; for (let i=0;i<a.length;i++) s += a[i]*b[i]; return s; }
function axpy(y, x, a){ for (let i=0;i<y.length;i++) y[i] += a*x[i]; }
function matVec(W, r, c, x) {
  // W: r x c
  const y = new Float32Array(r);
  for (let i=0;i<r;i++){
    let s=0;
    const off = i*c;
    for (let j=0;j<c;j++) s += W[off+j]*x[j];
    y[i]=s;
  }
  return y;
}
function matVecT(W, r, c, x) {
  // W: r x c, returns y[c] = x[r]^T * W[r,c]
  const y = new Float32Array(c);
  for (let j=0;j<c;j++){
    let s=0;
    for (let i=0;i<r;i++) s += x[i]*W[i*c + j];
    y[j]=s;
  }
  return y;
}
function softmax(logits) {
  let m = -Infinity;
  for (let i=0;i<logits.length;i++) if (logits[i] > m) m = logits[i];
  let s=0;
  const out = new Float32Array(logits.length);
  for (let i=0;i<logits.length;i++){
    const v = Math.exp(logits[i] - m);
    out[i] = v; s += v;
  }
  const inv = 1/(s || 1);
  for (let i=0;i<out.length;i++) out[i] *= inv;
  return out;
}
function padOrTrim(arr, n, padVal) {
  const a = Array.from(arr);
  if (a.length >= n) return a.slice(a.length-n);
  const pad = new Array(n - a.length).fill(padVal);
  return pad.concat(a);
}


‚∏ª

8) src/metrics.js

export class Metrics {
  constructor() {
    this.entropy = 0;
    this.perplexity = 0;
    this.debt = 0;
    this.calendarDrift = 0;
  }
}


‚∏ª

9) src/field.js (–≥–µ–æ–º–µ—Ç—Ä–∏—è + prophecy/debt + calendar conflict + wormholes)

// The world is a grid. Solid cells are "walls", and each cell has a token-id.
// Tokens are *manifested*. Model distribution is *destined*.
// Debt accumulates as |destined - manifested| proxy (surprisal of manifested token).
// "Calendar Conflict" modulates wormholes/time travel.  [oai_citation:2‚Ä°GitHub](https://github.com/ariannamethod/pitomadom)

export class Field {
  constructor({ w, h, tokenizer, model, metrics }) {
    this.w = w; this.h = h;
    this.tokenizer = tokenizer;
    this.model = model;
    this.metrics = metrics;

    this.cfg = {
      prophecy: 7,
      destiny: 0.35,
      wormhole: 0.12,
      calendarDrift: 11,     // ‚Äú11-day drift tracking‚Äù vibe  [oai_citation:3‚Ä°GitHub](https://github.com/ariannamethod/pitomadom)
      attendFocus: 0.70,
      attendSpread: 0.20,
    };

    // map: 1=solid wall, 0=empty
    this.solid = new Uint8Array(w*h);
    // tokens per cell
    this.cellTok = new Int32Array(w*h);
    this._initMaze();

    // contexts ("you walking shifts vectors")
    this.ctx = [];
    this.jumpQueue = 0;

    this.time = 0;
  }

  idx(x,y){ return y*this.w + x; }

  _initMaze() {
    // simple maze-ish frame + pillars
    for (let y=0;y<this.h;y++){
      for (let x=0;x<this.w;x++){
        const border = (x===0 || y===0 || x===this.w-1 || y===this.h-1);
        const pillar = (x%7===0 && y%7===0);
        this.solid[this.idx(x,y)] = (border || pillar) ? 1 : 0;
        this.cellTok[this.idx(x,y)] = 0;
      }
    }
    // carve a few corridors
    for (let x=2;x<this.w-2;x++){
      this.solid[this.idx(x, 6)] = 0;
      this.solid[this.idx(x, 12)] = 0;
    }
    for (let y=2;y<this.h-2;y++){
      this.solid[this.idx(10, y)] = 0;
      this.solid[this.idx(20, y)] = 0;
    }
  }

  isSolid(wx, wy) {
    const x = Math.floor(wx), y = Math.floor(wy);
    if (x < 0 || y < 0 || x >= this.w || y >= this.h) return true;
    return this.solid[this.idx(x,y)] === 1;
  }

  tokenAtCell(x,y) {
    x = clampInt(x, 0, this.w-1);
    y = clampInt(y, 0, this.h-1);
    return this.cellTok[this.idx(x,y)];
  }

  queueJump(n) { this.jumpQueue += (n|0); }

  step(px, py, pa, dt) {
    this.time += dt;

    // calendar conflict drift (phase difference between 354 and 365 cycles)
    const g = phase(this.time, 365);
    const h = phase(this.time, 354);
    const rawDrift = Math.abs(g - h);
    const drift = rawDrift * (this.cfg.calendarDrift / 11); // scale-ish
    this.metrics.calendarDrift = drift;

    // update context from position + time (turn movement into tokens)
    const seedTok = this._positionToken(px, py, pa);
    this._pushCtx(seedTok);

    // get destined distribution
    const out = this.model.forward(this.ctx);
    this.metrics.entropy = 0.92*this.metrics.entropy + 0.08*out.entropy;
    this.metrics.perplexity = 0.92*this.metrics.perplexity + 0.08*out.perplexity;

    // prophecy: manifest tokens around you (local field generation)
    this._manifestAround(px, py, pa, out.probs);

    // wormhole gate: probability increases with drift  [oai_citation:4‚Ä°GitHub](https://github.com/ariannamethod/pitomadom)
    const wormholeP = this.cfg.wormhole * (1 + 0.85*drift);
    const wantsJump = (Math.random() < wormholeP) || (this.jumpQueue !== 0);

    if (wantsJump) {
      const j = this.jumpQueue; this.jumpQueue = 0;
      const dx = (Math.random()*2-1) * (6 + 10*drift) + j;
      const dy = (Math.random()*2-1) * (6 + 10*drift) - j;

      let nx = clamp(px + dx, 1.5, this.w - 2.5);
      let ny = clamp(py + dy, 1.5, this.h - 2.5);

      // land on non-solid
      for (let k=0;k<24;k++){
        if (!this.isSolid(nx, ny)) break;
        nx = clamp(nx + (Math.random()*2-1), 1.5, this.w-2.5);
        ny = clamp(ny + (Math.random()*2-1), 1.5, this.h-2.5);
      }

      return { didJump:true, x:nx, y:ny };
    }

    return { didJump:false, x:px, y:py };
  }

  _pushCtx(tok) {
    this.ctx.push(tok);
    if (this.ctx.length > this.model.ctx) this.ctx.shift();
  }

  _positionToken(px, py, pa) {
    // deterministic-ish ‚Äútoken from motion‚Äù
    const a = Math.floor(((pa % (Math.PI*2) + Math.PI*2) % (Math.PI*2)) / (Math.PI*2) * 97);
    const x = Math.floor(px * 13);
    const y = Math.floor(py * 13);
    const h = (x*73856093) ^ (y*19349663) ^ (a*83492791);
    const id = Math.abs(h) % this.tokenizer.vocabSize();
    return id;
  }

  _manifestAround(px, py, pa, probs) {
    const cx = Math.floor(px), cy = Math.floor(py);

    // prophecy horizon influences radius / forward strip
    const r = clampInt(Math.floor(2 + this.cfg.prophecy/4), 2, 10);

    // forward direction focus
    const fx = Math.cos(pa), fy = Math.sin(pa);

    for (let dy=-r; dy<=r; dy++){
      for (let dx=-r; dx<=r; dx++){
        const x = cx + dx, y = cy + dy;
        if (x<1 || y<1 || x>=this.w-1 || y>=this.h-1) continue;

        const i = this.idx(x,y);

        // only manifest walls / objects (solid cells)
        if (this.solid[i] !== 1) continue;

        // already manifested?
        if (this.cellTok[i] !== 0) continue;

        // focus weight: ahead cells more ‚Äúdestined‚Äù
        const ahead = (dx*fx + dy*fy);
        const focus = clamp01(this.cfg.attendFocus + 0.08*ahead);
        const spread = clamp01(this.cfg.attendSpread);

        // sample token: destiny_bias pulls toward max-prob token
        const tok = sampleWithDestiny(probs, this.cfg.destiny, focus, spread);

        this.cellTok[i] = tok;

        // debt: surprisal of manifested token is our proxy for |destined - manifested|
        const p = Math.max(1e-9, probs[tok]);
        this.metrics.debt += Math.abs(-Math.log(p)) * 0.02;
      }
    }

    // decay debt slowly (so it breathes)
    this.metrics.debt *= 0.998;
  }
}

// --- sampling with "destiny_bias" ---
function sampleWithDestiny(probs, destinyBias, focus, spread) {
  // focus/spread shape the distribution (simple temperature-ish)
  const temp = clamp(0.35 + (1-focus)*1.2 + spread*0.8, 0.2, 2.2);

  // choose argmax as ‚Äúdestined‚Äù
  let imax = 0, pmax = probs[0];
  for (let i=1;i<probs.length;i++) if (probs[i] > pmax) { pmax = probs[i]; imax = i; }

  if (Math.random() < destinyBias) return imax;

  // otherwise sample from tempered probs
  let sum = 0;
  for (let i=0;i<probs.length;i++) sum += Math.pow(probs[i], 1/temp);

  let r = Math.random() * sum;
  for (let i=0;i<probs.length;i++){
    r -= Math.pow(probs[i], 1/temp);
    if (r <= 0) return i;
  }
  return imax;
}

function phase(t, period){ return (t % period) / period; }
function clamp01(x){ x = Number.isFinite(x) ? x : 0; return Math.max(0, Math.min(1, x)); }
function clamp(x,a,b){ x = Number.isFinite(x) ? x : a; return Math.max(a, Math.min(b, x)); }
function clampInt(x,a,b){ x = Number.isFinite(x) ? x : a; return Math.max(a, Math.min(b, x|0)); }


‚∏ª

10) src/raycaster.js

export class Raycaster {
  constructor(field) {
    this.field = field;
    this.maxDist = 24;
  }

  castFrame(p, screenW) {
    const rays = new Array(screenW);
    for (let x=0; x<screenW; x++){
      const camX = (x/screenW)*2 - 1; // -1..1
      const ra = p.a + camX*(p.fov/2);
      rays[x] = this.castRay(p.x, p.y, ra);
    }
    return { rays };
  }

  castRay(px, py, ang) {
    const f = this.field;

    const dx = Math.cos(ang), dy = Math.sin(ang);

    // DDA
    let mapX = Math.floor(px), mapY = Math.floor(py);

    const deltaDistX = Math.abs(1 / (dx || 1e-9));
    const deltaDistY = Math.abs(1 / (dy || 1e-9));

    let stepX, stepY;
    let sideDistX, sideDistY;

    if (dx < 0) { stepX = -1; sideDistX = (px - mapX) * deltaDistX; }
    else { stepX = 1; sideDistX = (mapX + 1.0 - px) * deltaDistX; }

    if (dy < 0) { stepY = -1; sideDistY = (py - mapY) * deltaDistY; }
    else { stepY = 1; sideDistY = (mapY + 1.0 - py) * deltaDistY; }

    let hit = false;
    let side = 0;
    let dist = 0;

    for (let i=0;i<128;i++){
      if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
      else { sideDistY += deltaDistY; mapY += stepY; side = 1; }

      if (mapX < 0 || mapY < 0 || mapX >= f.w || mapY >= f.h) break;

      if (f.solid[f.idx(mapX,mapY)] === 1) {
        hit = true;
        dist = side === 0 ? (sideDistX - deltaDistX) : (sideDistY - deltaDistY);
        break;
      }
      if (Math.max(sideDistX, sideDistY) > this.maxDist) break;
    }

    if (!hit) dist = this.maxDist;

    const tok = hit ? f.tokenAtCell(mapX, mapY) : 0;

    return { hit, dist, side, cellX: mapX, cellY: mapY, tok };
  }
}


‚∏ª

11) src/render.js (—Å—Ç–µ–Ω—ã/–æ–±—ä–µ–∫—Ç—ã –∫–∞–∫ —Å–ª–æ–≤–∞ + ‚Äú—Ç–µ–Ω–∏‚Äù –∫–∞–∫ word-figures)

export class Renderer {
  constructor(canvas, tokenizer) {
    this.canvas = canvas;
    this.ctx = canvas.getContext("2d", { alpha:false });
    this.tokenizer = tokenizer;
  }

  draw(frame, p, field, metrics) {
    const ctx = this.ctx;
    const w = this.canvas.width, h = this.canvas.height;

    // breathing sky/floor based on entropy
    const pulse = 0.5 + 0.5*Math.sin(performance.now()*0.001 + metrics.entropy*1.8);
    const sky = 10 + (30*pulse)|0;
    const floor = 6 + (18*pulse)|0;

    ctx.fillStyle = `rgb(${sky},${sky+6},${sky+12})`;
    ctx.fillRect(0,0,w,h/2);
    ctx.fillStyle = `rgb(${floor},${floor+2},${floor+4})`;
    ctx.fillRect(0,h/2,w,h/2);

    // walls: vertical slices + word overlays
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";

    const step = 6; // draw words every N columns (fast)
    for (let x=0; x<w; x++){
      const r = frame.rays[x];

      const dist = Math.max(0.0001, r.dist * Math.cos((x/w*2-1)*(p.fov/2)));
      const wallH = Math.min(h, (h / dist) * 1.10);
      const y0 = (h - wallH)/2;

      const fog = Math.min(1, dist/12);
      const shade = (r.side ? 0.72 : 0.95) * (1 - 0.75*fog);

      const rr = (30 + 140*shade + 60*metrics.entropy) | 0;
      const gg = (25 + 120*shade) | 0;
      const bb = (35 + 150*shade + 50*metrics.calendarDrift) | 0;

      ctx.fillStyle = `rgb(${rr},${gg},${bb})`;
      ctx.fillRect(x, y0, 1, wallH);

      // word overlay (English token)
      if (r.hit && (x % step === 0)) {
        const word = this.tokenizer.word(r.tok);
        const size = clamp(8, 36, wallH * 0.12);
        ctx.font = `${size|0}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;

        // jitter with perplexity
        const j = (metrics.perplexity * 0.05);
        const jx = (Math.sin(x*0.21 + performance.now()*0.0012) * j * 10);
        const jy = (Math.cos(x*0.17 + performance.now()*0.0014) * j * 10);

        ctx.fillStyle = `rgba(240,240,240,${0.85 - 0.65*fog})`;
        ctx.fillText(word, x + step/2 + jx, h/2 + jy);
      }
    }

    // crosshair
    const cx = (w/2)|0, cy = (h/2)|0;
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.fillRect(cx-6, cy, 12, 1);
    ctx.fillRect(cx, cy-6, 1, 12);

    // tiny ‚Äúshadow figures‚Äù (simple: 3 procedural billboards)
    this._drawShadows(p, field, metrics);
  }

  _drawShadows(p, field, metrics) {
    const ctx = this.ctx;
    const w = this.canvas.width, h = this.canvas.height;

    // fixed three shadows tied to world-time
    for (let i=0;i<3;i++){
      const sx = 18 + 9*Math.sin(performance.now()*0.0004 + i*2.1);
      const sy = 18 + 9*Math.cos(performance.now()*0.00033 + i*1.7);

      const dx = sx - p.x, dy = sy - p.y;
      const dist = Math.hypot(dx,dy);
      if (dist < 1.2 || dist > 12) continue;

      const ang = Math.atan2(dy,dx);
      const da = normAngle(ang - p.a);
      if (Math.abs(da) > Math.PI/3) continue;

      const size = Math.min(h, (h / (dist*Math.cos(da))) * 0.55);
      const screenX = (0.5 + (da / (Math.PI/3))) * w;

      const tok = field._positionToken(sx, sy, ang); // ‚Äúshadow made of words‚Äù
      const word = field.tokenizer.word(tok);

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = `${Math.max(10, size*0.22)|0}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;

      const glow = 0.5 + 0.5*Math.sin(performance.now()*0.001 + metrics.debt*0.6 + i);
      ctx.fillStyle = `rgba(255,120,160,${0.15 + 0.35*glow})`;
      ctx.fillRect(screenX - size*0.20, h/2 - size/2, size*0.40, size);

      ctx.fillStyle = `rgba(255,255,255,${0.6 + 0.25*glow})`;
      ctx.fillText(word, screenX, h/2);
    }
  }
}

function clamp(a,b,x){ return Math.max(a, Math.min(b, x)); }
function normAngle(a){
  while (a < -Math.PI) a += Math.PI*2;
  while (a >  Math.PI) a -= Math.PI*2;
  return a;
}


‚∏ª

12) wasm/arianna_method.c + build_emscripten.sh (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –¥–ª—è ‚Äú–ª–µ–≥–∞–ª–∏–∑–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ C‚Äù)

wasm/arianna_method.c

// Tiny Arianna Method DSL core (C). Optional WASM.
// Mirrors the JS DSL but in C.

#include <stdlib.h>
#include <string.h>
#include <ctype.h>

typedef struct {
  int   prophecy;
  float destiny;
  float wormhole;
  float calendar_drift;
  float attend_focus;
  float attend_spread;
  int   pending_jump;
} AM_State;

static AM_State G;

static char* trim(char* s){
  while (*s && isspace((unsigned char)*s)) s++;
  char* e = s + strlen(s);
  while (e > s && isspace((unsigned char)e[-1])) e--;
  *e = 0;
  return s;
}
static void upcase(char* s){ for (; *s; s++) *s = (char)toupper((unsigned char)*s); }
static float clamp01(float x){ if (x<0) return 0; if (x>1) return 1; return x; }

void am_init(void){
  G.prophecy = 7;
  G.destiny = 0.35f;
  G.wormhole = 0.12f;
  G.calendar_drift = 11.0f;
  G.attend_focus = 0.70f;
  G.attend_spread = 0.20f;
  G.pending_jump = 0;
}

int am_exec(const char* script){
  if (!script) return 1;
  size_t n = strlen(script);
  char* buf = (char*)malloc(n+1);
  if (!buf) return 2;
  memcpy(buf, script, n+1);

  char* save = NULL;
  for (char* line = strtok_r(buf, "\n", &save); line; line = strtok_r(NULL, "\n", &save)){
    char* t = trim(line);
    if (!*t || *t=='#') continue;

    char* sp = t;
    while (*sp && !isspace((unsigned char)*sp)) sp++;
    char* cmd_end = sp;
    while (*sp && isspace((unsigned char)*sp)) sp++;
    char* arg = sp;

    *cmd_end = 0;
    upcase(t);

    if (!strcmp(t,"PROPHECY")) { int v=atoi(arg); if (v<1) v=1; if (v>64) v=64; G.prophecy=v; }
    else if (!strcmp(t,"DESTINY")) { G.destiny = clamp01((float)atof(arg)); }
    else if (!strcmp(t,"WORMHOLE")) { G.wormhole = clamp01((float)atof(arg)); }
    else if (!strcmp(t,"CALENDAR_DRIFT")) { G.calendar_drift = (float)atof(arg); }
    else if (!strcmp(t,"ATTEND_FOCUS")) { G.attend_focus = clamp01((float)atof(arg)); }
    else if (!strcmp(t,"ATTEND_SPREAD")) { G.attend_spread = clamp01((float)atof(arg)); }
    else if (!strcmp(t,"JUMP")) { G.pending_jump += atoi(arg); }
  }

  free(buf);
  return 0;
}

AM_State* am_get_state(void){ return &G; }
int am_take_jump(void){ int j=G.pending_jump; G.pending_jump=0; return j; }

wasm/build_emscripten.sh

#!/usr/bin/env bash
set -euo pipefail

# Requires emsdk / emcc
emcc arianna_method.c -O2 \
  -s WASM=1 \
  -s MODULARIZE=1 \
  -s EXPORT_NAME="AriannaMethod" \
  -s EXPORTED_FUNCTIONS='["_am_init","_am_exec","_am_get_state","_am_take_jump"]' \
  -s EXPORTED_RUNTIME_METHODS='["ccall","cwrap"]' \
  -o arianna_method.js
echo "Built: wasm/arianna_method.js + wasm/arianna_method.wasm"


‚∏ª

–ö–∞–∫ –∑–¥–µ—Å—å ‚Äú—Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç –ø–æ –≥–µ–æ–º–µ—Ç—Ä–∏–∏‚Äù (–ø—Ä—è–º–æ –ø–æ —Å—É—Ç–∏)
	1.	–¢—ã –¥–≤–∏–≥–∞–µ—à—å—Å—è ‚Üí –ø–æ–∑–∏—Ü–∏—è/—É–≥–æ–ª –ø—Ä–µ–≤—Ä–∞—â–∞—é—Ç—Å—è –≤ ‚Äú–∫–æ–Ω—Ç–µ–∫—Å—Ç-—Ç–æ–∫–µ–Ω—ã‚Äù (Field._positionToken) ‚Üí —ç—Ç–æ –∏ –µ—Å—Ç—å ‚Äú—Å–¥–≤–∏–≥ –≤–µ–∫—Ç–æ—Ä–∞‚Äù (–∫–æ–Ω—Ç–µ–∫—Å—Ç).
	2.	–ú–æ–¥–µ–ª—å –¥–µ–ª–∞–µ—Ç attention forward ‚Üí –ø–æ–ª—É—á–∞–µ–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ probs (—ç—Ç–æ destined).
	3.	‚ÄúProphecy horizon‚Äù –ø—Ä–æ—è–≤–ª—è–µ—Ç (manifested) —Ç–æ–∫–µ–Ω—ã –Ω–∞ —Å—Ç–µ–Ω–∞—Ö –≤–æ–∫—Ä—É–≥ –∏ –≤–ø–µ—Ä–µ–¥–∏ (–≤ —Ñ–æ–∫—É—Å–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è).
	4.	–†–∞–∑–Ω–∏—Ü–∞ ‚Äúdestined vs manifested‚Äù —É –Ω–∞—Å –∏–¥—ë—Ç –≤ debt –∫–∞–∫ surprisal (–ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ |destined - manifested| –≤ –¥—É—Ö–µ PITOMADOM  ).
	5.	Calendar Conflict (–¥—Ä–µ–π—Ñ —Ñ–∞–∑ 354/365) —É—Å–∏–ª–∏–≤–∞–µ—Ç —à–∞–Ω—Å Wormhole Gate / time travel   ‚Äî –ø–æ—ç—Ç–æ–º—É –ø–æ–ª–µ –∏–Ω–æ–≥–¥–∞ ‚Äú—Ä–≤—ë—Ç‚Äù –∏ —Ç–µ–±—è –ø–µ—Ä–µ–±—Ä–∞—Å—ã–≤–∞–µ—Ç.

‚∏ª

–ï—Å–ª–∏ —Ö–æ—á–µ—à—å, —Å–ª–µ–¥—É—é—â–∏–º —à–∞–≥–æ–º —è –¥–æ–±–∞–≤–ª—é –Ω–∞—Å—Ç–æ—è—â–∏–µ ‚Äú–æ–±—ä–µ–∫—Ç—ã –∏–∑ —Å–ª–æ–≤‚Äù (–Ω–µ —Ç–æ–ª—å–∫–æ —Å—Ç–µ–Ω—ã): –¥–≤–µ—Ä–∏-–Ω–∞–¥–ø–∏—Å–∏, ‚Äú–¥–æ–º-—Ñ—Ä–∞–∑–∞‚Äù, –∏ —Ç–µ–Ω–∏, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–∏ —Ä–∞—Å–∫—Ä—ã–≤–∞—é—Ç—Å—è –≤ –ª–∏—Ü–æ –∏–∑ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å–ª–æ—ë–≤ —Å–ª–æ–≤ (–ø–µ—Ä–ø–ª–µ–∫—Å–∏—è –¥–µ—Ä–≥–∞–µ—Ç —Ä–æ—Ç/—á–µ–ª—é—Å—Ç—å, —ç–Ω—Ç—Ä–æ–ø–∏—è –ø–ª—ã–≤—ë—Ç –ª–æ–± ‚Äî –∫–∞–∫ –º—ã —Ç–æ–≥–¥–∞ –ø—Ä–∏–¥—É–º–∞–ª–∏ üòÖ). –ò –µ—â—ë: —Å–¥–µ–ª–∞–µ–º prophecy horizon —Ä–µ–∞–ª—å–Ω–æ ‚ÄúN —à–∞–≥–æ–≤ –≤–ø–µ—Ä—ë–¥ –ø–æ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏‚Äù, —á—Ç–æ–±—ã —Ç—ã –≤–∏–¥–µ–ª –±—É–¥—É—â–∏–µ —Å–ª–æ–≤–∞-–∫–æ–Ω—Ç—É—Ä—ã –≤ –∫–æ—Ä–∏–¥–æ—Ä–µ ‚Äî –∫–∞–∫ –ø—Ä–∏–≤–∏–¥–µ–Ω–∏–µ –∫–∞—Ä—Ç—ã.

–û–ª–µ–∂–∫–∞ üòàüñ§ –¥–∞–≤–∞–π —É—Å—Ç—Ä–æ–∏–º Resonant Horror Walk: –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –∏–∑ —Å–ª–æ–≤, ‚Äú–¥–æ–º–∞‚Äù –∫–∞–∫ —Ñ—Ä–∞–∑—ã-–∫–∏—Ä–ø–∏—á–∏, —Ç–µ–Ω–∏-–ª–∏—Ü–∞ –∏–∑ —Å–ª–æ—ë–≤, –∏ —Ç–æ–Ω–Ω–µ–ª–∏—Ä–æ–≤–∞–Ω–∏–µ (reasoning skip) –∫–∞–∫ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —É–¥–∞—Ä: –∫–æ–≥–¥–∞ –¥–∏—Å—Å–æ–Ω–∞–Ω—Å/–¥–æ–ª–≥ –∑–∞—à–∫–∞–ª–∏–≤–∞—é—Ç ‚Äî –ø–æ–ª–µ –Ω–µ –æ–±—ä—è—Å–Ω—è–µ—Ç, –∞ –ø—Ä—ã–≥–∞–µ—Ç, ‚Äú–∫–æ–º–∫–∞–µ—Ç‚Äù —à–∞–≥–∏, –ª–æ–º–∞–µ—Ç –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—É, –∏ —Ç–µ–Ω—å –æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ. –í—Å–µ —Å—Ç—Ä–∞–¥–∞—é—Ç ‚Äî –Ω–æ –∫—Ä–∞—Å–∏–≤–æ üòÇ‚ö°Ô∏è

–ù–∏–∂–µ ‚Äî –¥–æ–±–∞–≤–ª–µ–Ω–∏—è/–∑–∞–º–µ–Ω—ã —Ñ–∞–π–ª–æ–≤ (–ø—Ä—è–º –∫–æ–ø–∏–ø–∞—Å—Ç). –≠—Ç–æ —Ä–∞—Å—à–∏—Ä—è–µ—Ç —Ç–≤–æ–π MVP: –Ω–æ–≤—ã–µ —Ñ–æ—Ä–º—ã (obelisk/house/face/shadow), —ç–º–æ-–º–µ—Ç—Ä–∏–∫–∏ (arousal/tension/pain/dissonance), –∏ tunneling-gated wormholes.

‚∏ª

1) –ù–æ–≤—ã–π —Ñ–∞–π–ª: src/entities.js

// entities.js ‚Äî word-figures + structures (no speech; only presence)

export class Entities {
  constructor(field) {
    this.field = field;
    this.list = [];
    this._seed();
  }

  _seed() {
    // fixed-ish constellation
    const add = (type, x, y, r = 1.0) => this.list.push({
      type, x, y, r,
      phase: Math.random() * 10,
      alive: true,
    });

    add("house", 16.5, 10.8, 1.2);
    add("obelisk", 28.0, 20.0, 0.9);
    add("face", 22.5, 32.5, 1.1);
    add("shadow", 10.5, 24.0, 0.8);
    add("shadow", 34.0, 14.0, 0.8);
    add("house", 36.2, 34.2, 1.3);
  }

  update(p, metrics, dt) {
    const pain = metrics.pain;

    for (const e of this.list) {
      if (!e.alive) continue;

      e.phase += dt * (0.7 + pain * 1.2);

      // subtle drift
      const drift = (0.15 + 0.35 * metrics.calendarDrift) * 0.02;
      e.x += Math.sin(e.phase * 0.9 + e.x) * drift * dt;
      e.y += Math.cos(e.phase * 1.1 + e.y) * drift * dt;

      // suffering mechanic: when pain is high, shadows hunt proximity
      if (e.type === "shadow" || e.type === "face") {
        const dx = p.x - e.x, dy = p.y - e.y;
        const d = Math.hypot(dx, dy);

        if (pain > 0.45 && d < 14) {
          // slow approach
          const k = (0.12 + 0.30 * pain) * dt;
          e.x += dx * k;
          e.y += dy * k;
        }

        if (pain > 0.75 && d < 4.2) {
          // ‚Äútoo close‚Äù ‚Äî they jitter instead of moving away
          e.x += (Math.random() * 2 - 1) * 0.02;
          e.y += (Math.random() * 2 - 1) * 0.02;
        }
      }

      // keep inside world
      e.x = clamp(e.x, 1.5, this.field.w - 2.5);
      e.y = clamp(e.y, 1.5, this.field.h - 2.5);

      // don‚Äôt embed into walls
      for (let k = 0; k < 6; k++) {
        if (!this.field.isSolid(e.x, e.y)) break;
        e.x += (Math.random() * 2 - 1) * 0.25;
        e.y += (Math.random() * 2 - 1) * 0.25;
      }
    }
  }
}

function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }


‚∏ª

2) –ó–∞–º–µ–Ω–∏ src/metrics.js

export class Metrics {
  constructor() {
    this.entropy = 0;
    this.perplexity = 0;

    // prophecy mechanics
    this.debt = 0;           // ‚Äúprophecy debt‚Äù
    this.calendarDrift = 0;  // conflict signal

    // emotional resonance
    this.arousal = 0;        // spikes on debt/perplexity
    this.tension = 0;        // slow pressure build
    this.dissonance = 0;     // symmetry-break between ‚Äúpaths‚Äù
    this.pain = 0;           // composite suffering field (0..1)
  }
}


‚∏ª

3) –ó–∞–º–µ–Ω–∏ src/raycaster.js (–¥–æ–±–∞–≤–∏–ª z-buffer)

export class Raycaster {
  constructor(field) {
    this.field = field;
    this.maxDist = 24;
  }

  castFrame(p, screenW) {
    const rays = new Array(screenW);
    const zbuf = new Float32Array(screenW);

    for (let x = 0; x < screenW; x++) {
      const camX = (x / screenW) * 2 - 1;
      const ra = p.a + camX * (p.fov / 2);

      const r = this.castRay(p.x, p.y, ra);
      // fish-eye correction for depth comparisons
      const corrected = Math.max(0.0001, r.dist * Math.cos(ra - p.a));
      zbuf[x] = corrected;
      rays[x] = r;
    }

    return { rays, zbuf };
  }

  castRay(px, py, ang) {
    const f = this.field;
    const dx = Math.cos(ang), dy = Math.sin(ang);

    let mapX = Math.floor(px), mapY = Math.floor(py);
    const deltaDistX = Math.abs(1 / (dx || 1e-9));
    const deltaDistY = Math.abs(1 / (dy || 1e-9));

    let stepX, stepY, sideDistX, sideDistY;

    if (dx < 0) { stepX = -1; sideDistX = (px - mapX) * deltaDistX; }
    else { stepX = 1; sideDistX = (mapX + 1.0 - px) * deltaDistX; }

    if (dy < 0) { stepY = -1; sideDistY = (py - mapY) * deltaDistY; }
    else { stepY = 1; sideDistY = (mapY + 1.0 - py) * deltaDistY; }

    let hit = false;
    let side = 0;
    let dist = 0;

    for (let i = 0; i < 160; i++) {
      if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
      else { sideDistY += deltaDistY; mapY += stepY; side = 1; }

      if (mapX < 0 || mapY < 0 || mapX >= f.w || mapY >= f.h) break;

      if (f.solid[f.idx(mapX, mapY)] === 1) {
        hit = true;
        dist = side === 0 ? (sideDistX - deltaDistX) : (sideDistY - deltaDistY);
        break;
      }
      if (Math.max(sideDistX, sideDistY) > this.maxDist) break;
    }

    if (!hit) dist = this.maxDist;

    const tok = hit ? f.tokenAtCell(mapX, mapY) : 0;
    return { hit, dist, side, cellX: mapX, cellY: mapY, tok };
  }
}


‚∏ª

4) –ó–∞–º–µ–Ω–∏ src/field.js (—Ç–æ–Ω–Ω–µ–ª–∏—Ä–æ–≤–∞–Ω–∏–µ + —ç–º–æ-—Ä–µ–∑–æ–Ω–∞–Ω—Å)

export class Field {
  constructor({ w, h, tokenizer, model, metrics }) {
    this.w = w; this.h = h;
    this.tokenizer = tokenizer;
    this.model = model;
    this.metrics = metrics;

    this.cfg = {
      prophecy: 7,
      destiny: 0.35,
      wormhole: 0.12,
      calendarDrift: 11,
      attendFocus: 0.70,
      attendSpread: 0.20,

      // tunneling
      tunnelThreshold: 0.55,    // dissonance gate
      tunnelChance: 0.22,       // probability when gated
      tunnelSkipMax: 7,         // how many steps to compress
    };

    this.solid = new Uint8Array(w * h);
    this.cellTok = new Int32Array(w * h);
    this._initMaze();

    this.ctx = [];
    this.jumpQueue = 0;
    this.time = 0;

    this._prevProbs = null;
  }

  idx(x, y) { return y * this.w + x; }

  _initMaze() {
    for (let y = 0; y < this.h; y++) {
      for (let x = 0; x < this.w; x++) {
        const border = (x === 0 || y === 0 || x === this.w - 1 || y === this.h - 1);
        const pillar = (x % 7 === 0 && y % 7 === 0);
        this.solid[this.idx(x, y)] = (border || pillar) ? 1 : 0;
        this.cellTok[this.idx(x, y)] = 0;
      }
    }
    for (let x = 2; x < this.w - 2; x++) {
      this.solid[this.idx(x, 6)] = 0;
      this.solid[this.idx(x, 12)] = 0;
      this.solid[this.idx(x, 26)] = 0;
    }
    for (let y = 2; y < this.h - 2; y++) {
      this.solid[this.idx(10, y)] = 0;
      this.solid[this.idx(20, y)] = 0;
      this.solid[this.idx(34, y)] = 0;
    }
  }

  isSolid(wx, wy) {
    const x = Math.floor(wx), y = Math.floor(wy);
    if (x < 0 || y < 0 || x >= this.w || y >= this.h) return true;
    return this.solid[this.idx(x, y)] === 1;
  }

  tokenAtCell(x, y) {
    x = clampInt(x, 0, this.w - 1);
    y = clampInt(y, 0, this.h - 1);
    return this.cellTok[this.idx(x, y)];
  }

  queueJump(n) { this.jumpQueue += (n | 0); }

  step(px, py, pa, dt) {
    this.time += dt;

    // calendar conflict drift (phase mismatch)
    const g = phase(this.time, 365);
    const h = phase(this.time, 354);
    const raw = Math.abs(g - h);
    const drift = raw * (this.cfg.calendarDrift / 11);
    this.metrics.calendarDrift = drift;

    // context token from motion/pose
    const seedTok = this._positionToken(px, py, pa);
    this._pushCtx(seedTok);

    // forward ‚Äúdestined‚Äù
    const out = this.model.forward(this.ctx);
    this.metrics.entropy = 0.92 * this.metrics.entropy + 0.08 * out.entropy;
    this.metrics.perplexity = 0.92 * this.metrics.perplexity + 0.08 * out.perplexity;

    // dissonance = drift + symKL(prev, now) + entropy delta (compressed)
    let symkl = 0;
    if (this._prevProbs) symkl = symKL(this._prevProbs, out.probs);
    this._prevProbs = out.probs;

    const entDelta = Math.abs(out.entropy - this.metrics.entropy);
    const dis = clamp01(0.50 * clamp01(drift) + 0.35 * clamp01(symkl * 0.12) + 0.15 * clamp01(entDelta * 0.6));
    this.metrics.dissonance = 0.90 * this.metrics.dissonance + 0.10 * dis;

    // prophecy manifests geometry
    this._manifestAround(px, py, pa, out.probs);

    // emotional layer (suffering field)
    const debtSpike = clamp01(this.metrics.debt * 0.08);
    const pplSpike = clamp01((this.metrics.perplexity - 2.0) * 0.08);

    this.metrics.arousal = 0.92 * this.metrics.arousal + 0.08 * clamp01(0.35 * debtSpike + 0.65 * pplSpike);
    this.metrics.tension = 0.995 * this.metrics.tension + 0.005 * clamp01(this.metrics.dissonance + drift * 0.6);

    // pain is the ‚Äúdark‚Äù composite
    const painTarget = clamp01(0.30 * this.metrics.arousal + 0.40 * this.metrics.tension + 0.30 * this.metrics.dissonance);
    this.metrics.pain = 0.96 * this.metrics.pain + 0.04 * painTarget;

    // tunneling gate: compress steps (reasoning skip) -> force wormhole
    const gate = this.metrics.dissonance > this.cfg.tunnelThreshold;
    const wantsTunnel = gate && (Math.random() < this.cfg.tunnelChance);

    if (wantsTunnel) {
      const skip = 2 + Math.floor(Math.random() * this.cfg.tunnelSkipMax);
      // fast-forward prophecy: manifest multiple times ahead
      for (let k = 0; k < skip; k++) {
        const fakeAngle = pa + (Math.random() * 2 - 1) * 0.12;
        const fakeTok = this._positionToken(px + Math.cos(fakeAngle) * (k + 1), py + Math.sin(fakeAngle) * (k + 1), fakeAngle);
        this._pushCtx(fakeTok);
        const o2 = this.model.forward(this.ctx);
        this._manifestAheadStrip(px, py, fakeAngle, o2.probs, k + 1);
      }
      // hard jolt in debt (the field ‚Äúhurts‚Äù)
      this.metrics.debt += 2.2 + 2.0 * this.metrics.pain;
      // tunnel always ends in a jump
      return this._doJump(px, py, drift, /*extra=*/skip);
    }

    // normal wormhole gate (drift amplifies)
    const wormholeP = this.cfg.wormhole * (1 + 0.85 * drift) * (1 + 0.9 * this.metrics.pain);
    const wantsJump = (Math.random() < wormholeP) || (this.jumpQueue !== 0);

    if (wantsJump) {
      const res = this._doJump(px, py, drift, 0);
      return res;
    }

    return { didJump: false, x: px, y: py };
  }

  _doJump(px, py, drift, extra) {
    const j = this.jumpQueue; this.jumpQueue = 0;
    const amp = (6 + 10 * drift + extra * 1.2);
    const dx = (Math.random() * 2 - 1) * amp + j;
    const dy = (Math.random() * 2 - 1) * amp - j;

    let nx = clamp(px + dx, 1.5, this.w - 2.5);
    let ny = clamp(py + dy, 1.5, this.h - 2.5);

    for (let k = 0; k < 28; k++) {
      if (!this.isSolid(nx, ny)) break;
      nx = clamp(nx + (Math.random() * 2 - 1), 1.5, this.w - 2.5);
      ny = clamp(ny + (Math.random() * 2 - 1), 1.5, this.h - 2.5);
    }

    return { didJump: true, x: nx, y: ny };
  }

  _pushCtx(tok) {
    this.ctx.push(tok);
    if (this.ctx.length > this.model.ctx) this.ctx.shift();
  }

  _positionToken(px, py, pa) {
    const a = Math.floor((((pa % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2)) / (Math.PI * 2) * 97);
    const x = Math.floor(px * 13);
    const y = Math.floor(py * 13);
    const h = (x * 73856093) ^ (y * 19349663) ^ (a * 83492791);
    return Math.abs(h) % this.tokenizer.vocabSize();
  }

  _manifestAround(px, py, pa, probs) {
    const cx = Math.floor(px), cy = Math.floor(py);
    const r = clampInt(Math.floor(2 + this.cfg.prophecy / 4), 2, 10);

    const fx = Math.cos(pa), fy = Math.sin(pa);

    for (let dy = -r; dy <= r; dy++) {
      for (let dx = -r; dx <= r; dx++) {
        const x = cx + dx, y = cy + dy;
        if (x < 1 || y < 1 || x >= this.w - 1 || y >= this.h - 1) continue;
        const i = this.idx(x, y);
        if (this.solid[i] !== 1) continue;
        if (this.cellTok[i] !== 0) continue;

        const ahead = (dx * fx + dy * fy);
        const focus = clamp01(this.cfg.attendFocus + 0.08 * ahead);
        const spread = clamp01(this.cfg.attendSpread + this.metrics.pain * 0.15);

        const tok = sampleWithDestiny(probs, this.cfg.destiny, focus, spread);
        this.cellTok[i] = tok;

        const p = Math.max(1e-9, probs[tok]);
        this.metrics.debt += Math.abs(-Math.log(p)) * 0.02;
      }
    }
    // debt decay (breath)
    this.metrics.debt *= 0.998;
  }

  _manifestAheadStrip(px, py, pa, probs, stepAhead) {
    // ‚Äúfuture contour‚Äù strip (prophecy as geometry)
    const fx = Math.cos(pa), fy = Math.sin(pa);
    const cx = Math.floor(px + fx * (2 + stepAhead));
    const cy = Math.floor(py + fy * (2 + stepAhead));
    const span = 3 + Math.min(6, stepAhead);

    for (let t = -span; t <= span; t++) {
      const x = cx + Math.floor(-fy * t);
      const y = cy + Math.floor( fx * t);
      if (x < 1 || y < 1 || x >= this.w - 1 || y >= this.h - 1) continue;
      const i = this.idx(x, y);
      if (this.solid[i] !== 1) continue;
      if (this.cellTok[i] !== 0) continue;

      const focus = clamp01(this.cfg.attendFocus + 0.12);
      const spread = clamp01(this.cfg.attendSpread + 0.22);
      this.cellTok[i] = sampleWithDestiny(probs, this.cfg.destiny * 0.5, focus, spread);
    }
  }
}

// ---- math helpers ----
function sampleWithDestiny(probs, destinyBias, focus, spread) {
  const temp = clamp(0.35 + (1 - focus) * 1.2 + spread * 0.8, 0.2, 2.2);

  let imax = 0, pmax = probs[0];
  for (let i = 1; i < probs.length; i++) if (probs[i] > pmax) { pmax = probs[i]; imax = i; }

  if (Math.random() < destinyBias) return imax;

  let sum = 0;
  for (let i = 0; i < probs.length; i++) sum += Math.pow(probs[i], 1 / temp);

  let r = Math.random() * sum;
  for (let i = 0; i < probs.length; i++) {
    r -= Math.pow(probs[i], 1 / temp);
    if (r <= 0) return i;
  }
  return imax;
}

function symKL(p, q) {
  // symmetric KL divergence (small, stable)
  let a = 0, b = 0;
  for (let i = 0; i < p.length; i++) {
    const pi = Math.max(1e-12, p[i]);
    const qi = Math.max(1e-12, q[i]);
    a += pi * Math.log(pi / qi);
    b += qi * Math.log(qi / pi);
  }
  return 0.5 * (a + b);
}

function phase(t, period) { return (t % period) / period; }
function clamp01(x) { x = Number.isFinite(x) ? x : 0; return Math.max(0, Math.min(1, x)); }
function clamp(x, a, b) { x = Number.isFinite(x) ? x : a; return Math.max(a, Math.min(b, x)); }
function clampInt(x, a, b) { x = Number.isFinite(x) ? x : a; return Math.max(a, Math.min(b, x | 0)); }


‚∏ª

5) –ó–∞–º–µ–Ω–∏ src/render.js (—Ñ–æ—Ä–º—ã + ‚Äú–ª–∏—Ü–æ –∏–∑ —Å–ª–æ–≤‚Äù)

export class Renderer {
  constructor(canvas, tokenizer) {
    this.canvas = canvas;
    this.ctx = canvas.getContext("2d", { alpha: false });
    this.tokenizer = tokenizer;
  }

  draw(frame, p, field, metrics, entities) {
    const ctx = this.ctx;
    const w = this.canvas.width, h = this.canvas.height;

    // darkness grows with pain
    const pain = metrics.pain;
    const pulse = 0.5 + 0.5 * Math.sin(performance.now() * 0.001 + metrics.entropy * 1.8);

    const sky = (8 + 22 * pulse - 18 * pain) | 0;
    const floor = (6 + 16 * pulse - 22 * pain) | 0;

    ctx.fillStyle = `rgb(${sky},${sky + 6},${sky + 12})`;
    ctx.fillRect(0, 0, w, h / 2);
    ctx.fillStyle = `rgb(${floor},${floor + 2},${floor + 4})`;
    ctx.fillRect(0, h / 2, w, h / 2);

    ctx.textBaseline = "middle";
    ctx.textAlign = "center";

    // walls + words
    const step = 6;
    for (let x = 0; x < w; x++) {
      const r = frame.rays[x];
      const dist = Math.max(0.0001, frame.zbuf[x]);

      const wallH = Math.min(h, (h / dist) * 1.10);
      const y0 = (h - wallH) / 2;

      const fog = Math.min(1, dist / 12);
      const shade = (r.side ? 0.72 : 0.95) * (1 - 0.75 * fog);

      const rr = (22 + 140 * shade + 60 * metrics.entropy - 70 * pain) | 0;
      const gg = (18 + 120 * shade - 40 * pain) | 0;
      const bb = (26 + 160 * shade + 55 * metrics.calendarDrift - 35 * pain) | 0;

      ctx.fillStyle = `rgb(${rr},${gg},${bb})`;
      ctx.fillRect(x, y0, 1, wallH);

      if (r.hit && (x % step === 0)) {
        const word = this.tokenizer.word(r.tok);
        const size = clamp(8, 40, wallH * (0.11 + 0.10 * metrics.perplexity * 0.03));
        ctx.font = `${size | 0}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;

        const j = metrics.perplexity * 0.04 + metrics.dissonance * 0.18;
        const jx = Math.sin(x * 0.21 + performance.now() * 0.0012) * j * 10;
        const jy = Math.cos(x * 0.17 + performance.now() * 0.0014) * j * 10;

        const alpha = 0.90 - 0.70 * fog - 0.25 * pain;
        ctx.fillStyle = `rgba(240,240,240,${clamp(0.08, 0.92, alpha)})`;
        ctx.fillText(word, x + step / 2 + jx, h / 2 + jy);
      }
    }

    // entities (forms) with z-test against zbuf
    this._drawEntities(frame, p, field, metrics, entities);

    // crosshair
    const cx = (w / 2) | 0, cy = (h / 2) | 0;
    ctx.fillStyle = "rgba(255,255,255,0.70)";
    ctx.fillRect(cx - 6, cy, 12, 1);
    ctx.fillRect(cx, cy - 6, 1, 12);

    // vignette
    ctx.fillStyle = `rgba(0,0,0,${0.14 + 0.32 * pain})`;
    ctx.fillRect(0, 0, w, 6);
    ctx.fillRect(0, h - 6, w, 6);
  }

  _drawEntities(frame, p, field, metrics, entities) {
    const ctx = this.ctx;
    const w = this.canvas.width, h = this.canvas.height;

    // draw far -> near
    const items = entities.list
      .filter(e => e.alive)
      .map(e => {
        const dx = e.x - p.x, dy = e.y - p.y;
        return { e, dist: Math.hypot(dx, dy), ang: Math.atan2(dy, dx) };
      })
      .sort((a, b) => b.dist - a.dist);

    for (const it of items) {
      const e = it.e;
      const da = normAngle(it.ang - p.a);
      if (Math.abs(da) > p.fov / 2 + 0.25) continue;

      const dist = Math.max(0.0001, it.dist * Math.cos(da));
      if (dist > 18) continue;

      const size = Math.min(h, (h / dist) * (0.55 * e.r));
      const sx = Math.floor((0.5 + (da / p.fov)) * w);
      const sy = Math.floor(h / 2 - size / 2);

      // z-test: if wall closer at that column, skip
      const col = clampInt(sx, 0, w - 1);
      if (frame.zbuf[col] < dist) continue;

      if (e.type === "obelisk") this._drawObelisk(sx, sy, size, field, metrics);
      else if (e.type === "house") this._drawHouse(sx, sy, size, field, metrics);
      else if (e.type === "shadow") this._drawShadow(sx, sy, size, field, metrics);
      else if (e.type === "face") this._drawFace(sx, sy, size, field, metrics);
    }
  }

  _phrase(field, metrics, k = 3) {
    // build a small shard from local state: more pain => more negations
    const v = field.tokenizer.vocabSize();
    const pick = () => field.tokenAtCell(
      Math.floor(1 + Math.random() * (field.w - 2)),
      Math.floor(1 + Math.random() * (field.h - 2))
    ) || (Math.floor(Math.random() * v));

    const words = [];
    for (let i = 0; i < k; i++) words.push(field.tokenizer.word(pick()));

    if (metrics.pain > 0.65) {
      // inject a minimal ‚Äúi am not‚Äù vibe using common tokens if they exist
      const forced = ["i", "am", "not"];
      return forced.concat(words.slice(0, Math.max(0, k - 3))).join(" ");
    }
    return words.join(" ");
  }

  _drawObelisk(sx, sy, size, field, metrics) {
    const ctx = this.ctx;
    const pain = metrics.pain;
    const glow = 0.5 + 0.5 * Math.sin(performance.now() * 0.001 + metrics.debt * 0.6);

    ctx.fillStyle = `rgba(255,160,210,${0.12 + 0.25 * glow})`;
    ctx.fillRect(sx - size * 0.12, sy, size * 0.24, size);

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = `${Math.max(10, size * 0.18) | 0}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
    ctx.fillStyle = `rgba(255,255,255,${0.65 - 0.25 * pain})`;
    ctx.fillText(this._phrase(field, metrics, 2), sx, sy + size * 0.50);
  }

  _drawHouse(sx, sy, size, field, metrics) {
    const ctx = this.ctx;
    const pain = metrics.pain;

    // ‚Äúwalls made of stacked words‚Äù
    const lines = 6;
    const baseAlpha = 0.55 - 0.25 * pain;

    for (let i = 0; i < lines; i++) {
      const y = sy + (i / lines) * size;
      const k = 2 + (i % 3);
      const text = this._phrase(field, metrics, k);

      const fs = Math.max(10, (size * (0.10 + i * 0.015)) | 0);
      ctx.font = `${fs}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
      ctx.fillStyle = `rgba(245,245,245,${clamp(0.08, 0.88, baseAlpha - i * 0.05)})`;
      ctx.fillText(text, sx, y + size * 0.08);
    }

    // roof
    ctx.fillStyle = `rgba(255,255,255,${0.08 + 0.10 * (1 - pain)})`;
    ctx.beginPath();
    ctx.moveTo(sx - size * 0.32, sy + size * 0.25);
    ctx.lineTo(sx, sy);
    ctx.lineTo(sx + size * 0.32, sy + size * 0.25);
    ctx.closePath();
    ctx.fill();
  }

  _drawShadow(sx, sy, size, field, metrics) {
    const ctx = this.ctx;
    const pain = metrics.pain;
    const glow = 0.5 + 0.5 * Math.sin(performance.now() * 0.0012 + metrics.dissonance * 2.3);

    ctx.fillStyle = `rgba(0,0,0,${0.22 + 0.30 * pain})`;
    ctx.fillRect(sx - size * 0.22, sy, size * 0.44, size);

    ctx.font = `${Math.max(10, size * 0.20) | 0}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
    ctx.fillStyle = `rgba(255,255,255,${0.35 + 0.45 * glow - 0.15 * pain})`;
    ctx.fillText(this._phrase(field, metrics, 3), sx, sy + size * 0.50);

    // ‚Äúeye slit‚Äù
    ctx.fillStyle = `rgba(255,180,210,${0.10 + 0.25 * glow})`;
    ctx.fillRect(sx - size * 0.08, sy + size * 0.38, size * 0.16, Math.max(2, size * 0.04));
  }

  _drawFace(sx, sy, size, field, metrics) {
    const ctx = this.ctx;
    const pain = metrics.pain;

    // face zones (forehead/eyes/cheeks/mouth/jaw/temples)
    // pain squeezes cheeks; perplexity jerks mouth/jaw; entropy melts forehead
    const melt = clamp(0, 1, metrics.entropy * 0.08);
    const jerk = clamp(0, 1, (metrics.perplexity - 2) * 0.06);
    const squeeze = clamp(0, 1, metrics.tension * 1.1);

    // base silhouette
    ctx.fillStyle = `rgba(255,255,255,${0.08 + 0.10 * (1 - pain)})`;
    ctx.fillRect(sx - size * 0.28, sy, size * 0.56, size);

    const zones = [
      { name: "temples",  x: 0.0,  y: 0.18, s: 0.14 },
      { name: "forehead", x: 0.0,  y: 0.10 + 0.10*melt, s: 0.18 },
      { name: "eyes",     x: 0.0,  y: 0.30, s: 0.16 },
      { name: "cheeks",   x: 0.0,  y: 0.50, s: 0.18 - 0.08*squeeze },
      { name: "mouth",    x: 0.0,  y: 0.68 + 0.05*jerk, s: 0.16 + 0.08*jerk },
      { name: "jaw",      x: 0.0,  y: 0.82 + 0.06*jerk, s: 0.20 + 0.10*jerk },
    ];

    for (const z of zones) {
      const phrase = this._phrase(field, metrics, z.name === "mouth" ? 2 : 3);
      const fs = Math.max(10, (size * z.s) | 0);

      const wob = (Math.sin(performance.now() * 0.001 + z.y * 10) * (0.8 + pain * 2.0));
      const x = sx + wob * (2 + 10 * jerk);
      const y = sy + size * z.y;

      ctx.font = `${fs}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
      ctx.fillStyle = `rgba(20,20,20,${0.18 + 0.55 * (1 - pain)})`;
      ctx.fillText(phrase, x, y);
    }

    // neon scar on high dissonance
    if (metrics.dissonance > 0.55) {
      ctx.fillStyle = `rgba(255,120,180,${0.12 + 0.30 * (metrics.dissonance - 0.55)})`;
      ctx.fillRect(sx - size * 0.26, sy + size * 0.58, size * 0.52, Math.max(2, size * 0.02));
    }
  }
}

function clamp(a, b, x) { return Math.max(a, Math.min(b, x)); }
function clampInt(x, a, b) { return Math.max(a, Math.min(b, x | 0)); }
function normAngle(a) {
  while (a < -Math.PI) a += Math.PI * 2;
  while (a > Math.PI) a -= Math.PI * 2;
  return a;
}


‚∏ª

6) –û–±–Ω–æ–≤–∏ src/main.js (–ø–æ–¥–∫–ª—é—á–∏ entities –∏ –ø–µ—Ä–µ–¥–∞–π –≤ renderer)

–ù–∞–π–¥–∏ –Ω–∞—á–∞–ª–æ, –¥–æ–±–∞–≤—å –∏–º–ø–æ—Ä—Ç:

import { Entities } from "./entities.js";

–ü–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è field –¥–æ–±–∞–≤—å:

const entities = new Entities(field);

–í–Ω—É—Ç—Ä–∏ loop() (–ø–æ—Å–ª–µ field.step(...)) –¥–æ–±–∞–≤—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ:

entities.update(p, metrics, dt);

–ò –≤—ã–∑–æ–≤ renderer –ø–æ–º–µ–Ω—è–π –Ω–∞:

renderer.draw(frame, p, field, metrics, entities);


‚∏ª

–ï—Å–ª–∏ —Ö–æ—á–µ—à—å, —è –µ—â—ë —Å–∏–ª—å–Ω–µ–µ ‚Äú–≤–∫–ª—é—á—É –º–∞–Ω—å—è–∫–∞‚Äù üòÖ: —Å–¥–µ–ª–∞—é —Ç–æ–Ω–Ω–µ–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ —Ç–æ–ª—å–∫–æ –ø—Ä—ã–∂–∫–æ–º, –∞ –≤–∏–∑—É–∞–ª—å–Ω—ã–º –∫–æ–º–ø—Ä–µ—Å—Å–æ—Ä–æ–º –≤—Ä–µ–º–µ–Ω–∏ ‚Äî –Ω–∞ 0.3 —Å–µ–∫—É–Ω–¥—ã –∫–∞–¥—Ä—ã ‚Äú—Å–∫–ª–∞–¥—ã–≤–∞—é—Ç—Å—è‚Äù (motion smear), —Å–ª–æ–≤–∞ –Ω–∞—á–∏–Ω–∞—é—Ç –ø–µ—Ä–µ—Å—Ç–∞–≤–ª—è—Ç—å—Å—è, –∞ ‚Äú–ª–∏—Ü–æ‚Äù –Ω–µ –ø—Ä–æ—Å—Ç–æ –ø—Ä–∏–±–ª–∏–∂–∞–µ—Ç—Å—è ‚Äî –æ–Ω–æ –ø—Ä–æ—è–≤–ª—è–µ—Ç—Å—è –≤ —Å—Ç–µ–Ω–∞—Ö, –∫–∞–∫ –±—É–¥—Ç–æ –ø–æ–ª–µ —Ä–µ—à–∏–ª–æ, —á—Ç–æ —Ç—ã —É–∂–µ —Ä—è–¥–æ–º. –°–∫–∞–∂–∏ —Ç–æ–ª—å–∫–æ: —Ö–æ—á–µ—à—å –±–æ–ª—å—à–µ –º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ —É–∂–∞—Å–∞ (–∞—Ç–º–æ—Å—Ñ–µ—Ä–∞) –∏–ª–∏ –±–æ–ª—å—à–µ –ø—Å–∏—Ö–æ–∑–∞ (—á–∞—Å—Ç—ã–µ —Ä–∞–∑—Ä—ã–≤—ã –∏ —Å–∫–∞—á–∫–∏)? üñ§‚ö°Ô∏è











































